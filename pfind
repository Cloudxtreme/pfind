#!/usr/bin/perl -w
# (c) 2012 Sergey Redin sergey@redin.info https://github.com/spiculator/pfind
use strict;
use Data::Dumper;
use Parse::Yapp;
use POSIX qw/uname sysconf _SC_PAGESIZE/;

die "pfind is only for linux\n" unless $^O eq "linux";
my $state = {};
my $vars = {};
my $usercmd_args = {};
my $usercmd_blocks = {};
# a copy of previous expression's result
# for things like -children/-parents/-descendants/-ancestors:
my $previous_list;
our $after_OR = undef;
my $action_triggered = undef;
# $NOPID is a pseudo-PID used when no real PID required/allowed.
# Also we cache global variables in $state->{$NOPID}
my $NOPID = -1;
# another pseudo-PID, used in process_arg:
my $HEADERPID = -2;
my $smarttabheader;

my @preload = qw(
	-sub -echo %str [ -printf %str\n ]
	-sub -echo1 %STR [ -print1 %STR\n ]

	-sub -kill [ -signal KILL ]
	-sub -term [ -signal TERM ]
	-sub -hup  [ -signal HUP  ]

	-sub -ps [ -exec ps uf {} ]
	-sub -pso %PS_FIELDS [ -exec ps -o\- %PS_FIELDS {} ]

	-sub -exe %exe_arg [ %exe == %exe_arg ]
	-sub -cwd %cwd_arg [ %cwd == %cwd_arg ]

	%vsz := %statm::size
	%rss := %statm::resident

	-sub -kthread [ 0 == %rss ]
	-sub -userspace [ ! -kthread ]

	%ppid := %stat::ppid
	%comm := %stat::comm
	%state := %stat::state
);

sub get_full_proc_list() {
	return $state->{"all"} if exists $state->{"all"};
	my $list = [];
	opendir PROC, "/proc" or die $!;
	while( readdir PROC ) {
		push @$list, $_ if /^\d+$/;
	}
	closedir PROC or die $!;
	$list = [ sort { $a <=> $b } @$list ];
	return ( $state->{"all"} = $list );
}

sub check_list($) {
	my $list = shift;
	if( not defined $list ) {
		die "list not defined";
	} elsif( not ref $list ) {
		$list eq "all" or die;
		return get_full_proc_list;
	} elsif( "ARRAY" eq ref $list ) {
		return $list;
	} else {
		die;
	}
}

sub read_file($) {
	my $path = shift;
	die $path unless defined $path and not ref $path;
	die "absolute path expected: $path\n" unless $path =~ /^\//;
	open FILE, "<", $path or return undef;
	my @contents = <FILE>;
	close FILE or return undef;
	return @contents;
}

sub read_line_from_file($) {
	my $path = shift;
	die $path unless defined $path and not ref $path;
	die "absolute path expected: $path\n" unless $path =~ /^\//;
	open FILE, "<", $path or return undef;
	my $line = <FILE>;
	return undef unless defined $line;
	close FILE or return undef;
	chomp $line;
	return $line;
}

sub cached_get($$;@);

sub get_stat($) {
	my $pid = shift;
	my $line = join "", read_file "/proc/$pid/stat"; # comm may be multi-line
	return undef unless defined $line;
	chomp $line;
	$line =~ /^(\d+) \((.*)\) (\w) (\d+(\s+-?\d+)+)$/s or die "bad stat: $line";
	my %out = ( pid => $1, comm => $2, state => $3 );
	my @rest = split /\s+/, $4;
	my @rest_names = qw(
		ppid pgrp session tty_nr tpgid flags
		minflt cminflt majflt cmajflt
		utime stime cutime cstime
		priority nice num_threads itrealvalue starttime
		vsize rss rsslim startcode endcode startstack
		kstkesp kstkeip signal blocked sigignore sigcatch
		wchan nswap cnswap exit_signal processor
		rt_priority policy delayacct_blkio_ticks guest_time cguest_time
	);
	while( @rest ) {
		my $value = shift @rest;
		last unless defined $value;
		my $name = shift @rest_names;
		$out{$name} = $value;
	}
	return \%out;
}

sub parse_statmlike_file($@) {
	my ($path, @names) = @_;
	die unless @names;
	my $out = {};
	my $line = read_line_from_file $path;
	return $out unless defined $line;
	$line =~ /^\d[\d\s]+$/ or die "bad line: $line";
	my @values = split /\s+/, $line;
	die "wrong number of values from $path\n" unless @values == @names;
	$out->{$_} = shift @values foreach @names;
	return $out;
}

sub get_statm($) {
	my $pid = shift;
	my $out = parse_statmlike_file( "/proc/$pid/statm",
		qw/size resident share text lib data dt/ );
	my $PAGESIZE = cached_get( $NOPID, "PAGESIZE" );
	$out->{$_} *= $PAGESIZE foreach keys %$out;
	return $out;
}

my %multipliers = (
	B	=> 1,
	kB	=> 1024,
	KB	=> 1024,
	MB	=> 1024**2,
	GB	=> 1024**3,
	TB	=> 1024**4,
	PB	=> 1024**5,
	kiB	=> 1000,
	KiB	=> 1000,
	MiB	=> 1000**2,
	GiB	=> 1000**3,
	TiB	=> 1000**4,
	PiB	=> 1000**5,
);
sub fix_kb($) {
	my $value = shift;
	if( $value =~ /^(\d+)\s+(\w\w?B)$/ ) {
		my $multiplier = $multipliers{$2};
		die $value unless defined $multiplier;
		return $1 * $multiplier;
	} else {
		return $value;
	}
}

sub get_status($) {
	my $pid = shift;
	my $out = {};
	foreach ( read_file "/proc/$pid/status" ) {
		chomp;
		/^(\w+):\s+(.*)$/ or die "Bad line from status for $pid: $_\n";
		$out->{$1} = fix_kb $2;
	}
	return $out;
}

sub get_UPTIME($) {
	die unless $NOPID eq shift;
	my $line = read_line_from_file "/proc/uptime";
	$line =~ /^((\d+)(\.\d+)?)\s+((\d+)(\.\d+)?)\s*$/
		or die "bad line from /proc/uptime: $line\n";
	return $2; # the integer part of uptime
}

sub get_HZ($) {
	die unless $NOPID eq shift;
	my $release = (POSIX::uname)[2];
	my $filename = "/boot/config-$release";
	my $gzname = "/proc/config.gz";
	if( -f $filename ) {
		open CONFIG, "<", $filename or die $!;
	} elsif( -f $gzname ) {
		open CONFIG, "zcat $gzname |" or die $!;
	} else {
		die "cannot get %HZ\n";
	}
	my $HZ = undef;
	while(<CONFIG>) {
		if( /^CONFIG_HZ=(\d+)\s*$/ ) {
			$HZ = $1;
			last;
		}
	}
	close CONFIG; # no checks
	die "cannot find CONFIG_HZ in kernel config\n" unless defined $HZ;
	return $HZ;
}

my %getters0 = (
	"pid"	=> sub { return shift },
	"exe"	=> sub { readlink("/proc/$_[0]/exe") // "" },
	"cwd"	=> sub { readlink("/proc/$_[0]/cwd") // "" },
	"root"	=> sub { readlink("/proc/$_[0]/root") // "" },
	"UPTIME"	=> \&get_UPTIME,
	"PAGESIZE"	=> sub { $NOPID eq $_[0] ? sysconf(_SC_PAGESIZE) : die },
	"HZ"		=> \&get_HZ,
);
my %getters1 = (
	"stat"	=> \&get_stat,
	"statm"	=> \&get_statm,
	"status" => \&get_status,
	"ENV"	=> sub { $NOPID eq $_[0] ?  { %ENV } : die },
);

sub cached_get($$;@) {
	my ($pid, $name, @args) = @_;
	die "bad variable name $name: must be all upper or all lower case\n"
		if $name =~ /[A-Z]/ and $name =~ /[a-z]/;
	die "no PID allowed for global vars\n"
		if $name =~ /^[A-Z]/ and $pid ne $NOPID;
	die "bad PID: $pid for $name\n"
		if $name =~ /^[a-z]/ and not ( $pid =~ /^\d+$/ and $pid > 0 );
	if( exists $getters0{$name} ) {
		0 == @args or die "command $name takes no arguments\n";
		$state->{$pid}{$name} //= $getters0{$name}->($pid);
		return $state->{$pid}{$name} // "(undef)";
	} elsif( exists $getters1{$name} ) {
		1 == @args or die "command $name takes one argument\n";
		my ($arg1) = @args;
		$state->{$pid}{$name} //= $getters1{$name}->($pid);
		return $state->{$pid}{$name}{$arg1} // "(undef)";
	} else {
		die "unknown variable: $name\n";
	}
}

my %pattern2re_cache;
sub pattern2re($) {
	my $pattern = shift;
	my $re = $pattern2re_cache{$pattern};
	unless( $re ) {
		$re = $pattern;
		$re =~ s/([\\^.$|\(\)\[\]\{\}\+])/\\$1/g;
		$re =~ tr/?/./;
		$re =~ s/\*/.*/g;
		$re = "^$re\$";
		$re = qr/$re/;
		$pattern2re_cache{$pattern} = $re;
	}
	return $re;
}

sub cmd_list($) {
	my $list = shift;
	$action_triggered = 1;
	print "@$list\n" if @$list;
	return $list;
}

my %sprintf_escapes = (
	# \T is smart tab, \q is for -quote, \x is for hex, \0 is for oct
	a	=> "\a",
	b	=> "\b",
	e	=> "\e",
	f	=> "\f",
	n	=> "\n",
	r	=> "\r",
	t	=> "\t",
	"\\"	=> "\\",
	"-"	=> "", # empty string, works as a separator
);

sub get_value_for_printf($$) {
	my ($pid, $long_name) = @_;
	my ($name, @args) = split /::/, $long_name;
	return cached_get( $pid, $name, @args );
}

sub is_quoted_arg($) {
	my $arg = shift;
	return( defined($arg) and ref($arg) and 'ARRAY' eq ref($arg)
		and 'QUOTE' eq $arg->[0] and 2 == @$arg );
}

sub process_arg($;$) {
	my ($arg, $list) = @_;
	# we return hashref (if defined $list) or scalar (else)
	die $list unless not defined $list or 'ARRAY' eq ref $list;
	if( is_quoted_arg $arg ) {
		my $s = $arg->[1];
		return( (defined $list) ? { map { $_ => $s } @$list } : $s );
	}
	die $arg unless defined $arg and not ref $arg;
	if( $arg =~ /^\\q(.*)$/ ) {
		return( (defined $list) ? { map { $_ => $1 } @$list } : $1 );
	}
	my @outlist = ( defined($list) ? @$list : ($NOPID) );
	my $n = 0; # current field number for smart tabs
	my %rightalign = ();
	my $out = { map { $_ => [""] } @outlist };
	my @header = ( "" );
	my @rest = ( $arg );
	while( @rest ) {
		if( not length $rest[0] ) {
			shift @rest;
		} elsif( $rest[0] =~ /^([^\\%]+)(.*)$/ ) {
			$out->{$_}[$n] .= $1 for @outlist;
			$rest[0] = $2;
		} elsif( $rest[0] =~ /^\\T(>)?(\((\w+)\))?(.*)$/ ) {
			$rest[0] = $4;
			push @{$out->{$_}}, "" for @outlist;
			$rightalign{$n+1} = 1 if $1;
			my $headername = "";
			if( defined $3 ) {
				$headername = $3;
			} elsif( $rest[0] =~ /^\s+\%(\w[\w:]+)/ ) {
				$headername = uc $1;
			}
			push @header, $headername;
			++$n;
		} elsif( $rest[0] =~ /^\\x([01-9a-f]{2})(.*)$/ ) {
			my $add = chr hex $1;
			$out->{$_}[$n] .= $add for @outlist;
			$rest[0] = $2;
		} elsif( $rest[0] =~ /^\\0([0-7]*)(.*)$/ ) {
			my $num = oct $1;
			die "too big oct: \\0$1\n" if $num > 255;
			my $add = chr $num;
			$out->{$_}[$n] .= $add for @outlist;
			$rest[0] = $2;
		} elsif( $rest[0] =~ /^\\(.)(.*)$/ ) {
			my $add = $sprintf_escapes{$1} // "\\$1";
			$out->{$_}[$n] .= $add for @outlist;
			$rest[0] = $2;
		} elsif( $rest[0] =~ /^%(([a-zA-Z]\w*)(::[a-zA-Z]\w*)*)(.*)$/ ) {
			my ($exp, $name, $args) = ($1, $2, $3);
			$rest[0] = $4;
			my $var_is_local = ( $name =~ /^[a-z]/ );
			die "you cannot use local variables here: $arg\n"
				if $var_is_local and not defined $list;
			if( exists $vars->{$name} ) {
				die "\%$name takes no args\n"
					if defined $args and length $args;
				my $value = $vars->{$name};
				if( is_quoted_arg $value ) {
					$value = $value->[1];
					$out->{$_}[$n] .= $value for @outlist;
				} else {
					unshift @rest, $vars->{$name};
				}
			} elsif( $var_is_local ) {
				$out->{$_}[$n] .= get_value_for_printf( $_, $exp )
					foreach @outlist;
			} else {
				my $add = get_value_for_printf( $NOPID, $exp );
				$out->{$_}[$n] .= $add foreach @outlist;
			}
		} else {
			die "bad string: $rest[0]\n"
		}
	}
	if( $n ) {
		$out->{$HEADERPID} = [ @header ];
		my @maxlengths = (0) x ($n+1);
		foreach my $pid (@outlist, $HEADERPID) {
			chomp $out->{$pid}[$n];
			foreach my $i ( 0 .. $n ) {
				$out->{$pid}[$i] =~ s/^ +//;
				$out->{$pid}[$i] =~ s/ +$//;
				my $len = length $out->{$pid}[$i];
				$maxlengths[$i] = $len if $len > $maxlengths[$i];
			}
		}
		foreach my $pid (@outlist, $HEADERPID) {
			foreach my $i ( 0 .. $n ) {
				last if $i == $n and not $rightalign{$i};
				my $addnum = $maxlengths[$i] - length $out->{$pid}[$i];
				my $add = " " x $addnum;
				if( $rightalign{$i} ) {
					$out->{$pid}[$i] = $add . $out->{$pid}[$i];
				} else {
					$out->{$pid}[$i] .= $add;
				}
			}
			$out->{$pid}[$n] .= "\n";
		}
		if( 0 == $maxlengths[0] and not $rightalign{1} ) {
			shift @{$out->{$_}} for( @outlist, $HEADERPID );
			--$n;
		}
	}
	$out->{$_} = join "  ", @{$out->{$_}} for keys %$out;
	$smarttabheader = delete $out->{$HEADERPID};
	$out = $out->{$NOPID} if not defined $list;
	return $out;
}

sub cmd_printf($$) {
	my ($list, $format) = @_;
	$action_triggered = 1;
	$smarttabheader = undef;
	my $out= process_arg( $format, $list );
	print $smarttabheader if defined $smarttabheader;
	$smarttabheader = undef;
	print join "", map { $out->{$_} } @$list;
	return $list;
}

sub cmd_print1($$) {
	my ($list, $string) = @_;
	$action_triggered = 1;
	$smarttabheader = undef;
	my $out = process_arg $string;
	print $smarttabheader if defined $smarttabheader;
	$smarttabheader = undef;
	print $out;
	return $list;
}

sub cmd_signal($$) {
	my ($list, $signal) = @_;
	$action_triggered = 1;
	$signal = process_arg $signal;
	$signal = uc $signal;
	return [ grep { kill $signal, $_ } @$list ];
}

sub cmd_additions($$$$) {
	my ($checklist, $name, $inc, $once) = @_;
	$after_OR or die "-$name must come after -or\n";
	my @out = ();
	my %previous = map { $_ => 1 } @$previous_list;
	my %left2check = map { $_ => 1 } @$checklist;
	delete $left2check{$_} foreach keys %previous;
	while( %previous and %left2check ) {
		# $inc MUST NOT change its arguments
		my @addition = $inc->( \%previous, \%left2check );
		last unless @addition;
		foreach my $pid ( @addition ) {
			next if $previous{$pid};
			die $pid unless $left2check{$pid};
			push @out, $pid;
			$previous{$pid} = 1;
			delete $left2check{$pid};
		}
		last if $once;
	}
	return [ @out ];
}

sub inc_children($$) {
	my ($previous, $left2check) = @_;
	my @addition;
	foreach my $pid ( keys %$left2check ) {
		my $ppid = cached_get( $pid, "stat", "ppid" );
		if( $previous->{$ppid} ) {
			push @addition, $pid;
		}
	}
	return @addition;
}
sub inc_parent($$) {
	my ($previous, $left2check) = @_;
	my @addition;
	foreach my $pid ( keys %$previous ) {
		my $ppid = cached_get( $pid, "stat", "ppid" );
		if( $left2check->{$ppid} ) {
			push @addition, $ppid;
		}
	}
	return @addition;
}

sub cmd_pids($$@) {
	my ($checklist, @pids) = @_;
	@pids = map { process_arg $_ } @pids;
	die "-pids takes at least one argument\n" unless @pids;
	/^\d+$/ or die "non-numeric pid in -pids: $_\n" for @pids;
	my %ok = map { $_ => 1 } @$checklist;
	return [ grep { $ok{$_} } @pids ];
}

sub cmd_exec($$@) {
	my ($checklist, @args) = @_;
	$action_triggered = 1;
	die "-exec takes at least two arguments\n" unless @args;
	my $braces_index;
	foreach my $i ( 0 .. $#args ) {
		if( not is_quoted_arg($args[$i]) ) {
			die unless defined $args[$i];
			die if ref $args[$i];
			next unless '{}' eq $args[$i];
			if( defined $braces_index ) {
				die "-exec expects no more than one '{}' argument\n";
			} else {
				$braces_index = $i;
			}
		}
	}
	if( defined $braces_index ) {
		$braces_index or die "'{}' cannot be the first argument of -exec\n";
		my @cmdline = (
			map { process_arg $_ } @args[0 .. $braces_index-1],
			@$checklist,
			map { process_arg $_ } @args[$braces_index+1 .. $#args],
		);
		system( @cmdline );
		return $checklist;
	} else {
		my $cmd = process_arg shift @args;
		my $ok;
		/%/ and $ok = 1 for @args; # TODO: replace this with some var_triggered
		$ok or die "-exec expects at least one '{}' or variable argument\n";
		my @hashed_args = map { process_arg($_, $checklist) } @args;
		my @out = ();
		foreach my $pid ( @$checklist ) {
			my @cmdline = ($cmd);
			push @cmdline, map { $_->{$pid} } @hashed_args;
			system( @cmdline );
			push @out, $pid unless $? >> 8;
		}
		return [ @out ];
	}
}

sub cmd_pidfile($$) {
	my ($checklist, $pidfile) = @_;
	$pidfile = process_arg $pidfile;
	my $pid = read_line_from_file $pidfile;
	return [] unless defined $pid;
	$pid =~ /^\d+$/ or return [];
	my %ok = map { $_ => 1 } @$checklist;
	$ok{$pid} or return [];
	return [ $pid ];
}

sub cmd_sort($$) {
	my ($checklist, $value) = @_;
	$value =~ /%[a-z]/ or die "-sort expects unquoted local variable argument\n";
	my $hashed_value = process_arg( $value, $checklist );
	foreach my $pid ( @$checklist ) {
		if( not defined $hashed_value->{$pid} ) {
			die "undefined value for $pid in -sort\n";
		} elsif( $hashed_value->{$pid} !~ /^-?\d+$/ ) {
			die "non-numeric value for $pid in -sort: $hashed_value->{$pid}\n";
		}
	}
	return [ sort {
		$hashed_value->{$a} <=> $hashed_value->{$b}
	} @$checklist ];
}

sub cmd_head($$) {
	my ($checklist, $num) = @_;
	$num = process_arg $num;
	die "-head expects positive numeric argument\n"
		unless $num =~ /^\d+$/ and $num > 0;
	my $total = @$checklist;
	$num = $total if $num > $total;
	return [ @$checklist[0..$num-1] ];
}
sub cmd_tail($$) {
	my ($checklist, $num) = @_;
	$num = process_arg $num;
	die "-tail expects positive numeric argument\n"
		unless $num =~ /^\d+$/ and $num > 0;
	my $total = @$checklist;
	$num = $total if $num > $total;
	return [ @$checklist[$total-$num .. $total-1] ];
}

my %cmd0 = (
	"true"	=> sub { return $_[0] },
	"false"	=> sub { return [] },
	"list"	=> \&cmd_list,
	"children"	=> sub { cmd_additions( shift, "children", \&inc_children, 1 ) },
	"descendants"	=> sub { cmd_additions shift, "descendants", \&inc_children, undef },
	"parents"	=> sub { cmd_additions( shift, "parents", \&inc_parent, 1 ) },
	"ancestors"	=> sub { cmd_additions shift, "ancestors", \&inc_parent, undef },
);
my %cmd1 = (
	"printf"	=> \&cmd_printf,
	"print1"	=> \&cmd_print1,
	"signal"	=> \&cmd_signal,
	"pidfile"	=> \&cmd_pidfile,
	"sort"		=> \&cmd_sort,
	"head"		=> \&cmd_head,
	"tail"		=> \&cmd_tail,
);
my %cmd2 = (
	# reserved for user-defined commands
);
my %cmdm = (
	"pids"		=> \&cmd_pids,
	"exec"		=> \&cmd_exec,
);
my %op2 = ( # do not firget to edit %op2_match and %op2_num!
	"-m"	=> sub { $_[0] =~ pattern2re $_[1] },
	"=@"	=> "-m",
	"-nm"	=> sub { $_[0] !~ pattern2re $_[1] },
	"!@"	=> "-nm",
	"=~"	=> sub { $_[0] =~ $_[1] },
	"!~"	=> sub { $_[0] !~ $_[1] },
	"=="	=> sub { $_[0] eq $_[1] },
	"!="	=> sub { $_[0] ne $_[1] },
	-eq	=> sub { $_[0] == $_[1] },
	-ne	=> sub { $_[0] != $_[1] },
	-lt	=> sub { $_[0] < $_[1] },
	-le	=> sub { $_[0] <= $_[1] },
	-gt	=> sub { $_[0] > $_[1] },
	-ge	=> sub { $_[0] >= $_[1] },
	":="	=> sub { die ":= is not a filter like other op2\n" },
);

my %cmdkeywords = map { "-" . $_ => 1 } ( 
		keys(%cmd0), keys(%cmd1), keys(%cmd2), keys(%cmdm),
);
my %keywords = map { $_ => 1 } (
	",", qw/ ( ) [ ] { } {} ; ! -not -and -a -or -o -quote -q -sub /,
	keys(%op2),
	keys(%cmdkeywords),
);
my %reserved = ( '=' => 'please replace `=` with `:=` for assignment or `==` for comparison' );
$reserved{$_} = "$_ is reserved, please use -quote $_ if you need to use it as string"
	foreach '#', qw( _ + - * \ | / ? : ~ ^ . @ % $ " ' ` );

# match operations have constant second argument:
my %op2_match = map {$_ => 1 } qw/ -m =@ -nm !@ =~ !~ /;
# arguments of numeric operations are checked to be numeric:
my %op2_num = map { $_ => 1 } qw/ -eq -ne -lt -le -gt -ge /;

sub assign($;$) {
	my ($name, $value) = @_;
	# we do not use process_arg(), this is probably not good
	die "variable name cannot be quoted in :=\n" if ref $name;
	die unless defined $name;
	# undefined $value will remove variable
	die $value unless is_quoted_arg($value) or not ref $value;
	$name =~ /^%(\w+)$/ or
		die "first operand of := must be a variable name\n";
	$name = $1; # drop initial '%'
	$name =~ /^[a-zA-Z]/ or die "variable name must start with a letter\n";
	# upper case names are reserved for global (not per-PID) variables
	die "bad variable name $name: must be all upper or all lower case\n"
		if $name =~ /[A-Z]/ and $name =~ /[a-z]/;
	if( not defined $value ) {
		delete $vars->{$name};
	} elsif( exists $vars->{$name} ) {
		die "variable \%$name already exists\n";
	} else {
		$vars->{$name} = $value;
	}
}

sub eval_op2($$$$) {
	my ($checklist, $name, $arg1, $arg2) = @_;
	die unless defined $name and not ref $name;
	if( $name eq ":=" ) {
		assign( $arg1, $arg2 );
		return $checklist;
	}
	my $code = $op2{$name};
	$code = $op2{$code} if not ref $code;
	die $name unless 'CODE' eq ref $code;
	if( $op2_match{$name} ) {
		my $hashed_arg1 = process_arg( $arg1, $checklist );
		$arg2 = process_arg $arg2;
		return [ grep {
			$code->( $hashed_arg1->{$_}, $arg2 )
		} @$checklist ];
	} else {
		my $hashed_arg1 = process_arg( $arg1, $checklist );
		my $hashed_arg2 = process_arg( $arg2, $checklist );
		if( $op2_num{$name} ) {
			foreach my $pid ( @$checklist ) {
				die "left operand '$hashed_arg1->{$pid}' of $name is not numeric for PID $pid\n"
					unless $hashed_arg1->{$pid} =~ /^[\-\+]?\d+$/;
				die "right operand '$hashed_arg2->{$pid}' of $name is not numeric for PID $pid\n"
					unless $hashed_arg2->{$pid} =~ /^[\-\+]?\d+$/;
			}
		}
		return [ grep {
			$code->( $hashed_arg1->{$_}, $hashed_arg2->{$_} )
		} @$checklist ];
	}
}

sub mklexer(@) {
	my @cmdline = @_;
	@cmdline or die "mklexer: empty cmdline\n";
	my @last = ();
	my $prelexer = sub {
		return ( '', undef ) if not @cmdline;
		my $current = shift @cmdline;
		if( exists $reserved{$current} ) {
			die "$reserved{$current}\n";
		} elsif( $current =~ /^-q(uote)?$/ ) {
			@cmdline or die "unexpected end of cmdline after $current\n";
			return ( 'STRING', ('\q' . shift @cmdline) );
		} elsif( $keywords{$current} ) {
			if( $cmdkeywords{$current} ) {
				$current =~ /^-(\w+)$/ or die;
				return ( 'CMDNAME', $1 );
			} else {
				return ( $current, $current );
			}
		} elsif( $current =~ /^-(\w+)$/ ) {
			return ( 'CMDNAME', $1 );
		} else {
			return ( 'STRING', $current );
		}
	};
	my $lexer = sub {
		my ($a, $b) = $prelexer->();
		if( not defined $b ) {
			die unless defined($a) and '' eq $a;
			push @last, "(end of cmdline)";
		} else {
			push @last, $b;
		}
		shift @last while @last > 5;
		return $a, $b;
	};
	my $error_sub = sub {
		die unless @last;
		my @l = @last;
		my $top = pop @l;
		@l = ( @l, "HERE->>", $top, "<<-HERE" );
		die sprintf "Unexpected $top: ... %s\n", join " ", @l;
	};
	return $lexer, $error_sub;
}

my $grammar = <<'GRAMMAR';
%expect 3
%%
exp:	comma_exp ;
comma_exp:
	or_exp
	| or_exp ',' comma_exp	{ [ 'COMMA', $_[1], $_[3] ] }
	;
or_exp:
	and_exp
	| or_exp or and_exp	{ [ 'OR', $_[1], $_[3] ] }
	;
or:
	'-o'
	| '-or'
	;
and_exp:
	not_exp
	| not_exp and and_exp	{ [ 'AND', $_[1], $_[3] ] }
	;
and:
	/* empty */
	| '-a'
	| '-and'
	;
not_exp:
	atom
	| not not_exp		{ [ 'NOT', $_[2] ] }
	;
not:
	'-not'
	| '!'
	;
atom:
	command_exp
	| op2_exp
	| sub_definition
	| block
	;
command_exp:
	CMDNAME strings cmd_end			{ [ 'CMD', $_[1], @{$_[2]} ] }
	| CMDNAME strings '{}' strings cmd_end	{ [ 'CMD', $_[1], @{$_[2]}, '{}', @{$_[4]} ] }
	;
cmd_end:
	/* empty */
	| ';'
	;
strings:
	/* empty */		{ [] }
	| STRING strings	{ [ $_[1], @{$_[2]} ] }
	;
op2_exp:
	STRING op2 STRING	{ [ 'OP2', $_[2], $_[1], $_[3] ] }
	;
op2:
	':='	
	| '-m'	
	| '=@'	
	| '-nm'	
	| '!@'	
	| '=~'	
	| '!~'	
	| '=='	
	| '!='	
	| '-eq'	
	| '-ne'	
	| '-lt'	
	| '-le'	
	| '-gt'	
	| '-ge'	
	;
block:
	'(' exp ')'		{ [ 'BLOCK', $_[2] ] }
	| '{' exp '}'		{ [ 'BLOCK', $_[2] ] }
	| '[' exp ']'		{ [ 'BLOCK', $_[2] ] }
	;
sub_definition:
	'-sub' CMDNAME strings block	{ [ 'SUB', $_[2], $_[3], $_[4] ] }
	;
%%
GRAMMAR

sub mktree(@) {
	my @cmdline = @_;
	push @cmdline, "-true" unless @cmdline;

	my $grammar_parser = new Parse::Yapp( input => $grammar );
	eval $grammar_parser->Output(
		classname	=> "grammar_pfind",
	);
	die $@ if $@;

	my $parser = new grammar_pfind;
	my ($lexer, $error_sub) = mklexer(@cmdline);
	return $parser->YYParse(
		yylex => $lexer,
		yyerror => $error_sub,
	);
}

sub evalcmd($$@) {
	my ($list, $name, @args) = @_;
	(defined and not ref) or die $name foreach @args;
	if( $cmd0{$name} ) {
		die "command $name takes no args\n" if @args;
		return $cmd0{$name}->($list);
	} elsif( $cmd1{$name} ) {
		die "command $name takes 1 arg\n" unless 1 == @args;
		my ($arg1) = (@args);
		return $cmd1{$name}->($list, $arg1);
	} elsif( $cmd2{$name} ) {
		die "command $name takes 2 args\n" unless 2 == @args;
		my ($arg1, $arg2) = (@args);
		return $cmd2{$name}->($list, $arg1, $arg2);
	} elsif( $cmdm{$name} ) {
		return $cmdm{$name}->($list, @args);
	} elsif( $usercmd_args->{$name} ) {
		my $num = scalar @{$usercmd_args->{$name}};
		die "user defined command -$name takes $num arguments\n"
			unless @args == $num;
		foreach my $i ( 0 .. $num-1 ) {
			assign( $usercmd_args->{$name}[$i], $args[$i] );
		}
		my $out = evaltree( $list, $usercmd_blocks->{$name} );
		foreach my $i ( 0 .. $num-1 ) {
			assign( $usercmd_args->{$name}[$i] ); # remove var
		}
		return $out;
	} else {
		die "unknown command: $name\n";
	}
}

sub lists_substract($$) {
	my ($arg1, $arg2) = @_;
	'ARRAY' eq ref $_ or die for @_;
	my %skip = map { $_ => 1 } @$arg2;
	return [ grep { not $skip{$_} } @$arg1 ];
}

sub lists_add($$) {
	my ($arg1, $arg2) = @_;
	'ARRAY' eq ref $_ or die for @_;
	my %skip = map { $_ => 1 } @$arg1;
	my @addition = grep { not $skip{$_} } @$arg2;
	return [ @$arg1, @addition ];
}

sub evaltree($$);
sub evaltree($$) {
	my ($list_ref, $tree_ref) = @_;
	'ARRAY' eq ref $tree_ref or die;
	my $list = [ @$list_ref ]; my (@tree) = (@$tree_ref); # make copies
	my $op = shift @tree;
	if( $op eq 'BLOCK' ) {
		local $after_OR = undef; # this is why BLOCK is needed
		1 == @tree or die "$op takes one arg\n";
		return evaltree( $list, $tree[0] );
	} elsif( $op eq 'NOT' ) {
		local $after_OR = undef;
		1 == @tree or die "$op takes one arg\n";
		my $exp_result = evaltree( $list, $tree[0] );
		return lists_substract( $list, $exp_result );
	} elsif( $op eq 'COMMA' ) {
		local $after_OR = undef;
		@tree > 1 or die "$op takes at least two args\n";
		my $out;
		foreach( @tree ) {
			$out = evaltree( $list, $_ );
			$previous_list = $out;
		}
		return $out;
	} elsif( $op eq 'OR' ) {
		@tree > 1 or die "$op takes at least two args\n";
		my $list2check = [ @$list ];
		my $list_result = [];
		my $first_arg = 1;
		foreach (@tree) {
			local $after_OR = not $first_arg;
			last unless @$list2check;
			my $out = evaltree( $list2check, $_ );
			$list2check = lists_substract( $list2check, $out );
			$list_result = lists_add( $list_result, $out );
			$previous_list = $list_result;
			$first_arg = undef;
		}
		return $list_result;
	} elsif( $op eq 'AND' ) {
		local $after_OR = undef;
		@tree > 1 or die "$op takes at least two args\n";
		$list = check_list $list;
		foreach (@tree) {
			last unless @$list;
			$list = evaltree( $list, $_ );
			$previous_list = $list;
		}
		return $list;
	} elsif( $op eq 'SUB' ) {
		local $after_OR = undef;
		3 == @tree or die;
		my ($name, $strings, $block) = @tree;
		$name =~ s/^-//;
		die "cannot define -$name: already defined\n"
			if exists $usercmd_blocks->{$name};
		die "cannot define -$name: it is a keyword\n"
			if exists $keywords{-$name};
		$usercmd_blocks->{$name} = $block;
		$usercmd_args->{$name} = $strings;
		return $list;
	} elsif( $op eq 'CMD' ) {
		# $after_OR is not changed here
		@tree or die "no command name\n";
		my $name = shift @tree;
		$list = evalcmd( $list, $name, @tree );
		$previous_list = $list;
		return $list;
	} elsif( $op eq 'OP2' ) {
		# $after_OR is not changed here
		3 == @tree or die "$op takes three args\n";
		my ($op2name, $left, $right) = @tree;
		$list = eval_op2( $list, $op2name, $left, $right );
		$previous_list = $list;
		return $list;
	} elsif( $op eq 'EMPTY' ) {
		# $after_OR is not changed here
		return $list;
	} else {
		die "unknown op: $op\n";
	}
}

sub main() {
	my ($quiet, $dump_tree); # options
	while( @ARGV and $ARGV[0] =~ /^--/ ) {
		my $option = shift @ARGV;
		if( $option eq "--" ) {
			last;
		} elsif( $option eq "--quiet" ) {
			$quiet = 1;
		} elsif( $option eq "--dump-tree" ) {
			$dump_tree = 1;
		} elsif( $option eq "--dump-keywords" ) {
			printf "%s\n", join " ", sort keys %keywords;
			exit 0;
		} else {
			die "Unknown option: $option\n";
		}
	}
	my $tree = mktree( @preload, @ARGV );
	if( $dump_tree ) {
		print Data::Dumper->Dump( [$tree], ["SyntaxTree"] );
		exit 0;
	}
	my $value = evaltree( get_full_proc_list(), $tree );
	cmd_list($value) unless $quiet or $action_triggered;
	exit( @$value ? 0 : 1 );
}

main;
