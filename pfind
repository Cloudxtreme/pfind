#!/usr/bin/perl -w
use strict;
use Parse::Yapp;
my $state;

sub get_full_proc_list() {
	return $state->{"all"} if exists $state->{"all"};
	my $list = [];
	opendir PROC, "/proc" or die $!;
	while( readdir PROC ) {
		push @$list, $_ if /^\d+$/;
	}
	closedir PROC or die $!;
	return ( $state->{"all"} = $list );
}

sub check_list($) {
	my $list = shift;
	if( not defined $list ) {
		die "list not defined";
	} elsif( not ref $list ) {
		$list eq "all" or die;
		return get_full_proc_list;
	} elsif( "ARRAY" eq ref $list ) {
		return $list;
	} else {
		die;
	}
}

my %getters0 = (
	-exe	=> sub { readlink("/proc/$_[0]/exe") // "" },
	-cwd	=> sub { readlink("/proc/$_[0]/cwd") // "" },
	-root	=> sub { readlink("/proc/$_[0]/root") // "" },
);

sub cached_get($$) {
	my ($pid, $name) = @_;
	if( $name eq "-pid" ) {
		return $pid;
	} elsif( exists $state->{$pid}{$name} ) {
		return $state->{$pid}{$name};
	} elsif( exists $getters0{$name} ) {
		return( $state->{$pid}{$name} = $getters0{$name}->($pid) );
	} else {
		die "unkown property: $name";
	}
}

sub find_by_prop($$$) {
	my ($list, $re, $name) = @_;
	$list = check_list $list;
	return [ grep { cached_get($_, $name) =~ /$re/ } @$list ];
}

sub func_list($) {
	my $list = shift;
	my @sorted = sort { $a <=> $b } @$list;
	print "@sorted\n";
	return $list;
}

my %sprintf_escapes = (
	a	=> "\a",
	b	=> "\b",
	f	=> "\f",
	n	=> "\n",
	r	=> "\r",
	t	=> "\t",
	0	=> "\0",
	"\\"	=> "\\",
);

sub do_sprintf_escape($) {
	my $char = shift;
	die unless 1 == length $char;
	return $sprintf_escapes{$char} // "\\$char";
}

sub get_value_for_printf($$) {
	my ($pid, $name) = @_;
	my @names = split /::/, $name;
	if( @names > 1 ) {
		...
	} else {
		return cached_get( $pid, "-$name" );
	}
}

sub func_printf($) {
	my ($list, $format) = @_;
	my @sorted = sort { $a <=> $b } @$list;
	my $out = "";
	foreach my $pid (@sorted) {
		my $add = $format;
		$add =~ s{\\(.)}{do_sprintf_escape($1)}ge;
		$add =~ s{\\x([01-9a-f][01-9a-f])}{chr hex $1}gie;
		$add =~ s{%([a-z]\w*(::[a-z]\w*)*)}{get_value_for_printf( $pid, $1 )}gie;
		$add =~ s{%\[([a-z]\w*(::[a-z]\w*)*)\]}{get_value_for_printf( $pid, $1 )}gie;
		$add =~ s{%\{([a-z]\w*(::[a-z]\w*)*)\}}{get_value_for_printf( $pid, $1 )}gie;
		$add =~ s{%\(([a-z]\w*(::[a-z]\w*)*)\)}{get_value_for_printf( $pid, $1 )}gie;
		$out .= $add;
	}
	print $out;
	return $list;
}

my %func0 = (
	-true	=> sub { return $_[0] },
	-false	=> sub { return [] },
	-list	=> \&func_list,
);
my %func1 = (
	-exe	=> sub { find_by_prop( shift, shift, "-exe" ) },
	-cwd	=> sub { find_by_prop( shift, shift, "-cwd" ) },
	-root	=> sub { find_by_prop( shift, shift, "-root" ) },
	-printf	=> \&func_printf,
);
my %func2 = (
	-status	=> sub { ... },
);

sub tokenize(@) {
	my @out = ();
	while(@_) {
		my $a = shift;
		if( $a =~ /^[\(\)\[\]\{\},]$/ ) { # parentheses and comma
			push @out, [ $a, $a ];
		} elsif( $a =~ /^-a(nd?)$/ ) {
			push @out, [ 'AND', $a ];
		} elsif( $a =~ /^-or?$/ ) {
			push @out, [ 'OR', $a ];
		} elsif( $a =~ /^-(\w+)$/ ) {
			if( $func0{$a} ) {
				push @out, [ 'FUNC', [ 'FUNC', $a ] ];
			} elsif( $func1{$a} ) {
				@_ or die "function $a must have an arg\n";
				push @out, [ 'FUNC', [ 'FUNC', $a, shift ] ];
			} elsif( $func2{$a} ) {
				@_ > 1 or die "function $a must have two args\n";
				push @out, [ 'FUNC', [ 'FUNC', $a, shift, shift ] ];
			}
		} else {
			die "unknown token: $a\n";
		}
	}
	return [ @out ];
}

sub mklexer($) {
	my $tokens_ref = shift;
	my @tokens = @$tokens_ref;
	return sub {
		if( @tokens ) {
			my $token = shift @tokens;
			return ( @$token );
		} else {
			return ( '', undef );
		}
	}
}

my $grammar = <<'GRAMMAR';
%%
exp:	comma_exp ;
comma_exp:
	or_exp
	| or_exp ',' comma_exp	{ [ 'COMMA', $_[1], $_[3] ] }
	;
or_exp:
	and_exp
	| and_exp OR or_exp	{ [ 'OR', $_[1], $_[3] ] }
	;
and_exp:
	atom
	| atom and and_exp	{ [ 'AND', $_[1], $_[3] ] }
	;
and:
	#empty
	| AND # -a | -and
	;
atom:
	FUNC
	| block
	;
block:
	'(' exp ')'		{ $_[2] }
	| '{' exp '}'		{ $_[2] }
	| '[' exp ']'		{ $_[2] }
	;
%%
GRAMMAR

sub mktree(@) {
	my @cmdline = @_;
	push @cmdline, "-true" unless @cmdline;

	my $grammar_parser = new Parse::Yapp( input => $grammar );
	eval $grammar_parser->Output(
		classname	=> "grammar_pfind",
	);
	die $@ if $@;

	my $parser = new grammar_pfind;
	return $parser->YYParse(
		yylex => mklexer( tokenize @cmdline ),
		yyerror => sub{ die "Parse error\n" },
	);
}

sub evalfunc($$@) {
	my ($list, $name, @args) = @_;
	if( $func0{$name} ) {
		die "function $name takes no args\n" if @args;
		return $func0{$name}->($list);
	} elsif( $func1{$name} ) {
		die "function $name takes 1 arg\n" unless 1 == @args;
		my ($arg1) = (@args);
		return $func1{$name}->($list, $arg1);
	} elsif( $func2{$name} ) {
		die "function $name takes 2 args\n" unless 2 == @args;
		my ($arg1, $arg2) = (@args);
		return $func2{$name}->($list, $arg1, $arg2);
	} else {
		die "unknown function: $name\n";
	}
}

sub evaltree($$);
sub evaltree($$) {
	my ($list, $tree_ref) = @_;
	'ARRAY' eq ref $tree_ref or die;
	my (@tree) = (@$tree_ref); # make a copy
	my $op = shift @tree;
	if( $op eq 'COMMA' ) {
		@tree > 1 or die "$op takes at least two args\n";
		my $out;
		$out = evaltree( $list, $_ ) foreach @tree;
		return $out;
	} elsif( $op eq 'OR' ) {
		@tree > 1 or die "$op takes at least two args\n";
		my %pid_set = ();
		foreach (@tree) {
			my $out = evaltree( $list, $_ );
			$pid_set{$_} = 1 foreach @$out;
		}
		return [ keys %pid_set ];
	} elsif( $op eq 'AND' ) {
		@tree > 1 or die "$op takes at least two args\n";
		$list = check_list $list;
		foreach (@tree) {
			last unless @$list;
			$list = evaltree( $list, $_ );
		}
		return $list;
	} elsif( $op eq 'FUNC' ) {
		@tree or die "no function name\n";
		my $name = shift @tree;
		return evalfunc( $list, $name, @tree );
	} else {
		die "unknown op: $op\n";
	}
}

my %is_action;
$is_action{$_} = 1 foreach qw/-list -printf/;
sub tree_has_actions($);
sub tree_has_actions($) {
	my $tree = shift;
	my @copy = @$tree;
	my $op = shift @copy;;
	if( $op =~ /^(COMMA|OR|AND)$/ ) {
		foreach my $subtree (@copy) {
			return 1 if tree_has_actions($subtree);
		}
		return undef;
	} elsif( $op eq 'FUNC' ) {
		my $name = shift @copy;
		return $is_action{$name};
	} else {
		die "unknown op: $op\n";
	}
}

sub main() {
	my $tree = mktree( @ARGV ); ############### ./pfind -true -or [ -exe test -cwd / -o -status envID 123 ]
	#use Data::Dumper; print "tree: ", Dumper $tree; ##############################
	my $do_print_list = not tree_has_actions($tree);
	my $value = evaltree( get_full_proc_list(), $tree );
	#use Data::Dumper; print "value: ", Dumper $value; ##############################
	func_list($value) if $do_print_list;
}

main;

#use Data::Dumper; print Dumper find_by_prop "all", "pe", "exe"; ################
#use Data::Dumper; print Dumper find_by_prop "all", "/proc/7613", "cwd"; ################
#use Data::Dumper; print Dumper $state; ##############

__END__

TODO:

make cached_get work with func2 (-status)
pattern_match() instead of ~= $re
(maybe) //= "" in cached_get
-use glob [ exp ] | -use perlre [ exp ] - WON'T, instead make globbing the default for functions and use "%a =~ re" for perlre
(maybe) reduce [AND exp1 [AND exp2 exp3]] to [AND exp1 exp2 exp3] etc
-xor (don't ask me why)
-not (aka !)
-print/-printf/-print0 / -fprint
%uptime -lt 50
-kernel-thread/-userspace (use VmSize in /status or PF_KTHREAD flag in /stat)
threads
-exec cmd {} +/';'
common description of shorthands for both getters (-title = -status title) and print directives (%title = %status::title)
func2 -status
remove check_list (just use get_full_proc_list() instead of "all")
check that printf works with %status::title (when it's done)
check what happens if we run printf on non-existent pids
-pidlist 1 243 435 345 ';'
FIXME: \x?? may produce % which will be used later in printf (not a bug?)
implement all ...
help, README.md and POD
-ps-u = -exec ps u {} +, -ps-j, -ps-jf
-ok (interactive -exec)
-signal, -kill = -signal hup, -term = -signal term, -hup = -signal hup, -exists = -signal 0 (-exists is not an action)
-opened, -reads, -writes, -locks
-sort asc/desc (and remove sorts in -list and -printf)
-pidfile /var/run/apache (think what happens if the pid is not in the pid list passed into the pidfile getter)
printf: %{func2{arbitrary arg with spaces and slashes}} (not really needed yet since -pidfile is not for printf)
-sprintf (should be allowed everywhere where simple string arg is allowed)
better -or semantics, just like it's done for -and (do not run second check for processes which are already checked by the first arg)
global vars: %::prefix := "some string" -printf "%::prefix %pid\n"; maybe find something better than %::a;
	also we need something like %::uptime (preset readonly global vars)
think about pfind exit status and its usage in scripts
(maybe) parse functions in parser, not just in tokenizer
see "ps -o" for more printf directives
(won't) compile formatted strings into subs
do not add to many functions, prefer things like %exe -m '*bash', %cwd =~ '^a', %runtime -lt %{interval{5days}}, %vsz -gt %{size{5m}} etc
-!m shorthand: "%exe -!m '*bash'" is "-not %exe -m '*bash'" (this seems to be the only useful case for such shorthand)
-lt/-gt/-eq/-ne for numeric comparison, ==/!= for strings, =~/!~ for perlre, := for assignment, = is never used
if string is started with % it is formatted (or a variable right before := operator), else it is quoted (not formatted);
	-sprintf <string> is always formatted, -quote <string> is always quoted
(maybe) some network checks
