#!/usr/bin/perl -w
# (c) 2012 Sergey Redin sergey@redin.info https://github.com/spiculator/pfind
use strict;
use Data::Dumper;
use Number::Bytes::Human qw(format_bytes);
use Parse::Yapp;
use POSIX qw/uname sysconf _SC_PAGESIZE/;

my @allpids = ();
my $globalcache = {};
my $localcache = {};
my %cache = ();
my $userfunc_args = {};
my $userfunc_values = {};
my $usercmd_args = {};
my $usercmd_blocks = {};
my %is_human;
# a copy of previous expression's result
# for things like -children/-parents/-descendants/-ancestors:
my $previous_list;
our $after_OR = undef;
my $action_triggered = undef;
# $NOPID is a pseudo-PID used when no real PID required/allowed.
my $NOPID = -1;

my $preload = <<'PRELOAD';
	%pid := %_

	-cmd -writeln %str { -write '%str\n' }
	-cmd -writeln1 %STR { -write1 '%STR\n' }

	-cmd -warn %WARN_MESSAGE { -warnf '%WARN_MESSAGE\n' }
	-cmd -abort { -exit 1 }
	-cmd -die %DIE_MESSAGE { -warn %DIE_MESSAGE -comma -abort }
	-if %UNAME/SYSNAME != Linux -then -die 'pfind is only for linux' -fi

	-cmd -kill { -signal KILL }
	-cmd -term { -signal TERM }
	-cmd -hup  { -signal HUP  }

	-cmd -ps { -exec ps uf {} }
	-cmd -pso %PS_FIELDS { -exec ps -quote -o %PS_FIELDS {} }

	%exe := %readlink{/proc/%_/exe}
	%cwd := %readlink{/proc/%_/cwd}
	%root := %readlink{/proc/%_/root}

	-cmd -exe %exe_arg { %exe == %exe_arg }
	-cmd -cwd %cwd_arg { %cwd == %cwd_arg }
	-cmd -pidfile %PIDFILENAME { %pid == %FILEGETLINE{%PIDFILENAME,lineno=0} }

	%vsz := %statm/size
	%rss := %statm/resident

	-cmd -kthread { 0 == %rss }
	-cmd -userspace { ! -kthread }

	%ppid := %stat/ppid
	%comm := %stat/comm

	%nice := %stat/nice
	%nice_flag := [ %nice -lt 0 ? '<' : %nice -gt 0 ? N : '' ]
	%s := %stat/state
	%state := %s%nice_flag

	%name := %status/Name

	-cmd -grep %GREP_ARG { %exe -m '*%GREP_ARG*'
		-or %comm -m '*%GREP_ARG*' -or %name -m '*%GREP_ARG*' }
	-cmd -egrep %EGREP_ARG { %exe '=~' %EGREP_ARG
		-or %comm '=~' %EGREP_ARG -or %name '=~' %EGREP_ARG }

	-human %vsz %rss ';'

	%command := %tree%name
	-cmd -pstree { -settree -echo %ppid %pid %state %rss %vsz %command }
PRELOAD

sub get_all_pids() {
	return @allpids if @allpids;
	opendir PROC, "/proc" or die $!;
	while( readdir PROC ) {
		push @allpids, $_ if /^\d+$/;
	}
	closedir PROC or die $!;
	@allpids = sort { $a <=> $b } @allpids;
	return @allpids;
}

sub check_defined_scalar($) {
	1 == @_ or die;
	my $value = shift;
	return if defined($value) and not ref($value);
	my ($package, $filename, $line) = caller;
	die sprintf "check_defined_scalar failed at %s line %s: %s\n",
		$filename, $line, Dumper($value);
}

sub read_file($) {
	my $path = shift;
	check_defined_scalar $path;
	die "absolute path expected: $path\n" unless $path =~ /^\//;
	open FILE, "<", $path or return undef;
	my @contents = <FILE>;
	close FILE or return undef;
	return @contents;
}

sub read_line_from_file($) {
	my $path = shift;
	check_defined_scalar $path;
	die "absolute path expected: $path\n" unless $path =~ /^\//;
	open FILE, "<", $path or return undef;
	my $line = <FILE>;
	return undef unless defined $line;
	close FILE or return undef;
	chomp $line;
	return $line;
}

sub cached_get($$;@);

sub get_stat($) {
	my $pid = shift;
	my $line = join "", read_file "/proc/$pid/stat"; # comm may be multi-line
	return undef unless defined $line;
	chomp $line;
	$line =~ /^(\d+) \((.*)\) (\w) (\d+(\s+-?\d+)+)$/s or die "bad stat: $line";
	my %out = ( pid => $1, comm => $2, state => $3 );
	my @rest = split /\s+/, $4;
	my @rest_names = qw(
		ppid pgrp session tty_nr tpgid flags
		minflt cminflt majflt cmajflt
		utime stime cutime cstime
		priority nice num_threads itrealvalue starttime
		vsize rss rsslim startcode endcode startstack
		kstkesp kstkeip signal blocked sigignore sigcatch
		wchan nswap cnswap exit_signal processor
		rt_priority policy delayacct_blkio_ticks guest_time cguest_time
	);
	while( @rest ) {
		my $value = shift @rest;
		last unless defined $value;
		my $name = shift @rest_names;
		$out{$name} = $value;
	}
	return \%out;
}

sub parse_statmlike_file($@) {
	my ($path, @names) = @_;
	die unless @names;
	my $out = {};
	my $line = read_line_from_file $path;
	return $out unless defined $line;
	$line =~ /^\d[\d\s]+$/ or die "bad line: $line";
	my @values = split /\s+/, $line;
	die "wrong number of values from $path\n" unless @values == @names;
	$out->{$_} = shift @values foreach @names;
	return $out;
}

sub get_statm($) {
	my $pid = shift;
	my $out = parse_statmlike_file( "/proc/$pid/statm",
		qw/size resident share text lib data dt/ );
	my $PAGESIZE = cached_get( $NOPID, "PAGESIZE" );
	$out->{$_} *= $PAGESIZE foreach keys %$out;
	return $out;
}

my %multipliers = (
	B	=> 1,
	kB	=> 1024,
	KB	=> 1024,
	MB	=> 1024**2,
	GB	=> 1024**3,
	TB	=> 1024**4,
	PB	=> 1024**5,
	kiB	=> 1000,
	KiB	=> 1000,
	MiB	=> 1000**2,
	GiB	=> 1000**3,
	TiB	=> 1000**4,
	PiB	=> 1000**5,
);
sub fix_kb($) {
	my $value = shift;
	if( $value =~ /^(\d+)\s+(\w\w?B)$/ ) {
		my $multiplier = $multipliers{$2};
		die $value unless defined $multiplier;
		return $1 * $multiplier;
	} else {
		return $value;
	}
}

sub get_status($) {
	my $pid = shift;
	my $out = {};
	foreach ( read_file "/proc/$pid/status" ) {
		chomp;
		/^(\w+):\s+(.*)$/ or die "Bad line from status for $pid: $_\n";
		$out->{$1} = fix_kb $2;
	}
	return $out;
}

sub get_UNAME() {
	my @values = uname;
	5 == @values or die "uname() must retun 5 values\n";
	my $out = {};
	$out->{$_} = shift @values
		foreach qw/SYSNAME NODENAME RELEASE VERSION MACHINE/;
	return $out;
}

sub get_UPTIME() {
	my $line = read_line_from_file "/proc/uptime";
	$line =~ /^((\d+)(\.\d+)?)\s+((\d+)(\.\d+)?)\s*$/
		or die "bad line from /proc/uptime: $line\n";
	return $2; # the integer part of uptime
}

sub get_HZ() {
	my $release = cached_get( $NOPID, "UNAME", "RELEASE" );
	my $filename = "/boot/config-$release";
	my $gzname = "/proc/config.gz";
	if( -f $filename ) {
		open CONFIG, "<", $filename or die $!;
	} elsif( -f $gzname ) {
		open CONFIG, "zcat $gzname |" or die $!;
	} else {
		die "cannot get %HZ\n";
	}
	my $HZ = undef;
	while(<CONFIG>) {
		if( /^CONFIG_HZ=(\d+)\s*$/ ) {
			$HZ = $1;
			last;
		}
	}
	close CONFIG; # no checks
	die "cannot find CONFIG_HZ in kernel config\n" unless defined $HZ;
	return $HZ;
}

my %getters0 = (
	"tree"		=> sub { "" }, # see -settree
	"UPTIME"	=> \&get_UPTIME,
	"PAGESIZE"	=> sub { sysconf(_SC_PAGESIZE) },
	"HZ"		=> \&get_HZ,
);
my %getters1 = (
	"stat"	=> \&get_stat,
	"statm"	=> \&get_statm,
	"status" => \&get_status,
	"UNAME"	=> \&get_UNAME,
);
my %getters = ( %getters0, %getters1 );

sub cached_get($$;@) {
	my ($pid, $name, @args) = @_;
	die "bad variable name $name: must be all upper or all lower case\n"
		if $name =~ /[A-Z]/ and $name =~ /[a-z]/;
	my $global = ( $name =~ /^[A-Z]/ );
	die "no PID allowed for global vars\n" if $global and $pid ne $NOPID;
	die "bad PID: $pid for $name\n"
		if not $global and not ( $pid =~ /^\d+$/ and $pid > 0 );
	die "unknown variable: $name\n" unless exists $getters{$name};
	my $num = ( exists($getters1{$name}) ? 1 : 0 );
	@args == $num or die "variable $name has $num subvariable(s)\n";
	my $gotit;
	if( $global ) {
		$gotit = ( $globalcache->{$name} //= $getters{$name}->() );
	} else {
		$gotit = ( $localcache->{$pid}{$name} //= $getters{$name}->($pid) );
	}
	return( $num ? $gotit->{$args[0]} : $gotit );
}

my %pattern2re_cache;
sub pattern2re($) {
	my $pattern = shift;
	my $re = $pattern2re_cache{$pattern};
	unless( $re ) {
		$re = $pattern;
		$re =~ s/([\\^.$|\(\)\[\]\{\}\+])/\\$1/g;
		$re =~ tr/?/./;
		$re =~ s/\*/.*/g;
		$re = "^$re\$";
		$re = qr/$re/;
		$pattern2re_cache{$pattern} = $re;
	}
	return $re;
}

sub cmd_list($) {
	my $list = shift;
	$action_triggered = 1;
	print "@$list\n" if @$list;
	return $list;
}

sub mk_simple_func(&$) {
	my ($code, $num_args) = @_;
	return sub {
		my ($list, $name, @args_in) = @_;
		$num_args == @args_in or die "%$name\{\} takes $num_args arg(s)\n";
		my @args_hashes = map {
			$list ? process_arg($_, $list) : { $NOPID => process_arg($_) }
		} @args_in;
		my @outlist = ( $list ? @$list : $NOPID );
		my %out;
		foreach my $pid ( @outlist ) {
			my @args = map { $_->{$pid} } @args_hashes;
			$out{$pid} = $code->(@args);
		}
		return \%out;
	};
}

sub get_file_lines($) {
	die unless 1 == @_;
	my $filename = shift;
	my $cache_key = "file_lines:$filename";
	return @{$cache{$cache_key}} if exists $cache{$cache_key};
	$filename =~ /^\// or die "bad filename: $filename\n";
	open FILE, "<", $filename or die "cannot open $filename: $!";
	my @out = <FILE>;
	close FILE or die $!;
	chomp foreach @out;
	$cache{$cache_key} = [@out];
	return @out;
}
sub func_filegetline($$$@) {
	my ($list, $name, $filename_arg, @named_args_arr) = @_;
	@_ >= 4 or die "%$name\{\} takes at least two args\n" . Dumper \@_;
	my %args_in = ( filename => $filename_arg );
	foreach ( @named_args_arr ) {
		/^(\w+)=(.*)$/ or die "bad arg format for $name: $_\n";
		$args_in{$1} = $2;
	}
	my @outlist = ( $list ? @$list : $NOPID );
	my $hashed_args;
	if( $list ) {
		$hashed_args->{$_} = process_arg( $args_in{$_}, $list )
			foreach keys %args_in;
	} else {
		$hashed_args->{$_} = { $NOPID => process_arg($args_in{$_}) }
			foreach keys %args_in;
	}
	my %out = map { $_ => "" } @outlist;
	foreach my $pid ( @outlist ) {
		my @lines = get_file_lines $hashed_args->{filename}{$pid};
		if( exists $hashed_args->{lineno} ) {
			my $num = $hashed_args->{lineno}{$pid};
			$out{$pid} = ( exists($lines[$num]) ? $lines[$num] : "" );
		} elsif( exists $hashed_args->{keynum} ) {
			my $keynum = $hashed_args->{keynum}{$pid};
			my $keyval = $hashed_args->{keyval}{$pid};
			die "%$name\{\}: no keyval parameter\n" unless defined $keyval;
			my $sep = $hashed_args->{sep}{$pid};
			$sep = ":" unless defined $sep;
			foreach my $l ( @lines ) {
				next if $l =~ /^\s*(#.*)?$/;
				my @fields = split $sep, $l;
				next unless $fields[$keynum] eq $keyval;
				if( exists $hashed_args->{fieldno} ) {
					my $fieldno = $hashed_args->{fieldno}{$pid};
					die "bad fieldno: $fieldno\n" unless $fieldno =~ /^\d+$/;
					$out{$pid} .= $fields[$fieldno] if exists $fields[$fieldno];
				} else {
					$out{$pid} .= $l;
				}
				last;
			}
		} else {
			die "%filegetline\{\}: not enough info how to get line from file\n";
		}
	}
	return \%out;
}

my %readlink_cache = ();
my $func_readlink = mk_simple_func {
	my $path = shift;
	die "%readlink\{\}: path must be absolute: $path\n" unless $path =~ /^\//;
	return ( $readlink_cache{$path} //= ( readlink($path) || "" ) );
} 1;

my $func_math = mk_simple_func {
	my $expr = shift;
	die "Bad %math\{\} argument value: $expr\n"
		unless $expr =~ /^[\d\-\+\*\/\(\)]+$/;
	my $value = eval $expr;
	die "%math\{\} syntax error: $expr\n"
		unless defined($value) and not ref($value);
	return $value;
} 1;

sub mk_human {
	$_[0] =~ /^([\-\+]?)(\d+)$/ ? $1 . (format_bytes($_[0]) || "-") : $_[0]
}
my $func_human = mk_simple_func \&mk_human, 1;

my $func_env = mk_simple_func { $ENV{shift()} || "" } 1;

my %sysfunc = (
	env		=>	$func_env,
	ENV		=>	$func_env,
	readlink	=>	$func_readlink,
	READLINK	=>	$func_readlink,
	math		=>	$func_math,
	MATH		=>	$func_math,
	human		=>	$func_human,
	HUMAN		=>	$func_human,
	filegetline	=>	\&func_filegetline,
	FILEGETLINE	=>	\&func_filegetline,
);

my %sprintf_escapes = (
	# \q is for -quote, \x is for hex, \0 is for oct
	a	=> "\a",
	b	=> "\b",
	e	=> "\e",
	f	=> "\f",
	n	=> "\n",
	r	=> "\r",
	s	=> " ",
	t	=> "\t",
	"\\"	=> "\\",
	"-"	=> "", # empty string, works as a separator
);

sub process_arg($;$);
sub process_conditional($$$$) {
	my ($list, $is_local, $out, $conditional) = @_;
	'ARRAY' eq ref $conditional or die;
	my @options = @$conditional;
	'CONDITIONAL' eq shift @options or die;
	@options > 1 or die;
	my $last = $options[$#options];
	'DEFAULT' eq $last->[0] or die;
	my $restlist = ( defined($list) ? [@$list] : [$NOPID] ) ;
	foreach my $o ( @options ) {
		last unless @$restlist;
		die unless 'ARRAY' eq ref $o;
		my ($curlist, $value);
		if( 'DEFAULT' eq $o->[0] ) {
			2 == @$o or die;
			$value = $o->[1];
			$curlist = [ @$restlist ];
			goto curlist_done;
		}
		'OPTION' eq $o->[0] or die;
		3 == @$o or die;
		( undef, my($cond), $value ) = @$o;
		my $negative;
		if( 'NOT' eq $cond->[0] ) {
			die unless 2 == @$cond;
			$negative = 1;
			$cond = $cond->[1];
		}
		die unless 4 == @$cond;
		die unless 'COMPARE' eq $cond->[0];
		my (undef, $cmp_name, $left, $right ) = @$cond;
		my $cmp_out = eval_compare( $list, $cmp_name, $left, $right );
		if( defined $list ) {
			$curlist = ( $negative ? lists_substract($list, $cmp_out) : $cmp_out );
		} else {
			$curlist = ( ($negative xor $cmp_out) ? [$NOPID] : [] );
		}
		curlist_done:
		die unless defined $curlist;
		die unless defined $value;
		if( $is_local ) {
			$list or die;
			my $add = process_arg( $value, $curlist );
			$out->{$_} .= $add->{$_} foreach @$curlist;
		} elsif( $list ) {
			my $add = process_arg $value;
			$out->{$_} .= $add foreach @$curlist;
		} elsif( 1 == @$curlist and -1 == $curlist->[0] ) {
			$out->{$NOPID} .= process_arg $value;
		} else {
			die unless 0 == @$curlist;
		}
		$restlist = lists_substract( $restlist, $curlist );
	}
	die if @$restlist;
}

sub process_value($$$) {
	my ($list, $out, $string) = @_;
	$string =~ /^%(([a-zA-Z]\w*)(\/[a-zA-Z]\w*)*)(.*)$/
		or die "bad func or var syntax: $string\n";
	my ($exp, $name, $subvars_str) = ($1, $2, $3);
	$string = $4;
	my @args = ();
	if( $string =~ /^\{/ ) {
		$string =~ /^\{([%\w\/,\.\-\+\*=]*)\}(.*)$/
			or die "bad arguments syntax: $string\n";
		$string = $2;
		if( length $1 ) {
			@args = split /,/, $1;
		}
	}
	my @outlist = ( defined($list) ? @$list : ($NOPID) );
	my $is_local = ( $name =~ /^[a-z]/ );
	die "you cannot use local variables here: $string\n"
		if $is_local and not defined $list;
	if( exists $sysfunc{$name} ) {
		die "\%$name takes no subvars\n"
			if defined $subvars_str and length $subvars_str;
		if( $is_local ) {
			$list or die;
			my $add = $sysfunc{$name}->($list, $name, @args);
			$out->{$_} .= $add->{$_} for @outlist;
		} else {
			my $add = $sysfunc{$name}->(undef, $name, @args);
			$out->{$_} .= $add->{$NOPID} foreach @outlist;
		}
	} elsif( exists $userfunc_values->{$name} ) {
		die "\%$name takes no subvars\n"
			if defined $subvars_str and length $subvars_str;
		my $value = $userfunc_values->{$name};
		my $need_args_ref = ( $userfunc_args->{$name} || [] );
		my @need_args = @$need_args_ref;
		if( @args > @need_args ) {
			die "%$name: too many arguments\n";
		} elsif( @args < @need_args ) {
			die "%$name: not enough arguments\n";
		} else {
			@args == @need_args or die;
			foreach my $i ( 0 .. $#need_args ) {
				assign( "%$need_args[$i]", $args[$i] );
			}
		}
		if( ref $value ) {
			process_conditional( $list, $is_local, $out, $value);
			assign( "%$_" ) foreach @need_args;
			return $string;
		}
		check_defined_scalar $value;
		if( $value =~ /^\\q(.*)$/ ) {
			$out->{$_} .= $1 for @outlist;
		} elsif( $is_local ) {
			$list or die;
			my $add = process_arg( $userfunc_values->{$name}, $list );
			$out->{$_} .= $add->{$_} for @outlist;
		} elsif( $list ) {
			my $add = process_arg $userfunc_values->{$name};
			$out->{$_} .= $add foreach @outlist;
		} else {
			$out->{$NOPID} .= process_arg $userfunc_values->{$name};
		}
		assign( "%$_" ) foreach @need_args;
	} else {
		my ($name, @subvars) = split /\//, $exp;
		die "system variables cannot have arguments: %$name\n" if @args;
		foreach my $pid ( @outlist ) {
			$out->{$pid} .= cached_get(
				( $is_local ? $pid : $NOPID ),
				$name, @subvars,
			);
		}
	}
	return $string;
}

sub process_arg($;$) {
	my ($arg, $list) = @_;
	# we return hashref (if defined $list) or scalar (else)
	die $list unless not defined $list or 'ARRAY' eq ref $list;
	check_defined_scalar $arg;
	if( $arg =~ /^\\q(.*)$/ ) {
		# see also process_value() for \q in userfunc values
		return( (defined $list) ? { map { $_ => $1 } @$list } : $1 );
	}
	my @outlist = ( defined($list) ? @$list : ($NOPID) );
	my $out = { map { $_ => "" } @outlist };
	my $rest = "$arg";
	while( length $rest ) {
		if( $rest =~ /^([^\\%]+)(.*)$/ ) {
			$out->{$_} .= $1 for @outlist;
			$rest = $2;
		} elsif( $rest =~ /^\\x([01-9a-f]{2})(.*)$/ ) {
			my $add = chr hex $1;
			$out->{$_} .= $add for @outlist;
			$rest = $2;
		} elsif( $rest =~ /^\\0([0-7]*)(.*)$/ ) {
			my $num = oct $1;
			die "too big oct: \\0$1\n" if $num > 255;
			my $add = chr $num;
			$out->{$_} .= $add for @outlist;
			$rest = $2;
		} elsif( $rest =~ /^\\(.)(.*)$/ ) {
			my $add = $sprintf_escapes{$1} // "\\$1";
			$out->{$_} .= $add for @outlist;
			$rest = $2;
		} elsif( $rest =~ /^%_(.*)$/ ) {
			$list or die "cannot use %_ here\n";
			$out->{$_} .= $_ for @outlist;
			$rest = $1;
		} elsif( $rest =~ /^%/ ) {
			$rest = process_value( $list, $out, $rest );
		} else {
			die "bad string: $rest\n"
		}
	}
	$out = $out->{$NOPID} if not defined $list;
	return $out;
}

sub print_table($$$@) {
	my ($list, $name, $with_header, @strings) = @_;
	my $once = not defined $list;
	$once or 'ARRAY' eq ref($list) or die;
	die "-$name expects at least one arg\n" unless @strings;

	my $columns = [];
	my $first_alignment;
	foreach my $str ( @strings ) {
		my ($header, $alignment, $human);
		if( $str =~ /((\w*)(\/\w+)?):(.+)$/ and length $1 ) {
			$str = $4;
			$header = $2 if length $2;
			$alignment = $3 if $3;
		}
		if( $str =~ /^%(\w[\w\/]*)$/ ) {
			$header = uc $1 if not defined $header;
			$human = 1 if $is_human{$1};
		}
		$alignment = "/auto" if not defined $alignment;
		$header = "" if not defined $header;
		my @values;
		if( $once ) {
			my $s = process_arg $str;
			@values = ( $s );
		} else {
			my $hashed_s = process_arg($str, $list);
			@values = map { $hashed_s->{$_} } @$list;
		}
		@values = map { mk_human $_ } @values if $human;
		if( $alignment eq "/center" ) {
			s/^\s*(.*[^\s])\s*$/$1/ foreach @values;
		}
		my $maxlength = 0;
		my $allnumeric = 1;
		foreach ( @values ) {
			$allnumeric = 0 if $allnumeric and not /^(-?\d+(\.\d+)?\w?)|-$/;
			my $l = length;
			$maxlength = $l if $l > $maxlength;
		}
		$allnumeric = 0 unless @values;
		if( $with_header ) {
			my $l = length $header;
			$maxlength = $l if $l > $maxlength;
		}
		$alignment = ( $allnumeric ? "/right" : "/left" ) if $alignment eq "/auto";
		$first_alignment = $alignment if not defined $first_alignment;
		my @column = @values;
		unshift @column, $header if $with_header;
		foreach my $i ( 0 .. $#column ) {
			my $need = $maxlength - length $column[$i];
			die if $need < 0;
			if( $alignment eq "/left" ) {
				$column[$i] .= " " x $need;
			} elsif( $alignment eq "/right" ) {
				$column[$i] = (" " x $need) . $column[$i];
			} elsif( $alignment eq "/center" ) {
				my $left = int( $need / 2 );
				my $right = $need - $left;
				$column[$i] = (" " x $left) . $column[$i] . (" " x $right);
			} else {
				die "unknown alignment: $alignment\n";
			}
		}
		push @$columns, \@column;
	}
	my $prefix = ( ($first_alignment eq "/left") ? "" : " " );
	my $table = "";
	while( @{$columns->[0]} ) {
		my @fields;
		foreach my $c ( @$columns ) {
			push @fields, shift @$c;
		}
		$table .= sprintf "%s%s\n", $prefix, join( "  ", @fields );
	}
	print $table;
	$action_triggered = 1;
}

sub do_write($$) {
	my ($list, $string) = @_;
	$action_triggered = 1;
	my $out = process_arg( $string, $list );
	print( $list ? join "", map { $out->{$_} } @$list : $out );
}

sub cmd_warnf($$) {
	my ($list, $string) = @_;
	print STDERR process_arg $string;
	return $list;
}

sub cmd_exit($$) {
	my ($list, $exitcode) = @_;
	$exitcode = process_arg $exitcode;
	$exitcode =~ /^\d+$/ or die "-exit argument must be numeric\n";
	exit $exitcode;
}

sub cmd_signal($$) {
	my ($list, $signal) = @_;
	$action_triggered = 1;
	$signal = process_arg $signal;
	$signal = uc $signal;
	return [ grep { kill $signal, $_ } @$list ];
}

sub get_additions($$$$) {
	my ($checklist, $name, $inc, $once) = @_;
	$after_OR or die "-$name must come after -or\n";
	my @out = ();
	my %previous = map { $_ => 1 } @$previous_list;
	my %left2check = map { $_ => 1 } @$checklist;
	delete $left2check{$_} foreach keys %previous;
	while( %previous and %left2check ) {
		# $inc MUST NOT change its arguments
		my @addition = $inc->( \%previous, \%left2check );
		last unless @addition;
		foreach my $pid ( @addition ) {
			next if $previous{$pid};
			die $pid unless $left2check{$pid};
			push @out, $pid;
			$previous{$pid} = 1;
			delete $left2check{$pid};
		}
		last if $once;
	}
	return [ @out ];
}

sub inc_children($$) {
	my ($previous, $left2check) = @_;
	my @addition;
	foreach my $pid ( keys %$left2check ) {
		my $ppid = cached_get( $pid, "stat", "ppid" );
		if( $previous->{$ppid} ) {
			push @addition, $pid;
		}
	}
	return @addition;
}
sub inc_parent($$) {
	my ($previous, $left2check) = @_;
	my @addition;
	foreach my $pid ( keys %$previous ) {
		my $ppid = cached_get( $pid, "stat", "ppid" );
		if( $left2check->{$ppid} ) {
			push @addition, $ppid;
		}
	}
	return @addition;
}

sub cmd_pids($$@) {
	my ($checklist, @pids) = @_;
	@pids = map { process_arg $_ } @pids;
	die "-pids takes at least one argument\n" unless @pids;
	/^\d+$/ or die "non-numeric pid in -pids: $_\n" for @pids;
	my %ok = map { $_ => 1 } @$checklist;
	return [ grep { $ok{$_} } @pids ];
}

sub cmd_exec($$@) {
	my ($checklist, @args) = @_;
	$action_triggered = 1;
	die "-exec takes at least two arguments\n" unless @args;
	my $braces_index;
	foreach my $i ( 0 .. $#args ) {
		if( '{}' eq $args[$i] ) {
			if( defined $braces_index ) {
				die "-exec expects no more than one '{}' argument\n";
			} else {
				$braces_index = $i;
			}
		}
	}
	if( defined $braces_index ) {
		$braces_index or die "'{}' cannot be the first argument of -exec\n";
		@$checklist or return $checklist;
		my @cmdline = (
			map { process_arg $_ } @args[0 .. $braces_index-1],
			@$checklist,
			map { process_arg $_ } @args[$braces_index+1 .. $#args],
		);
		system( @cmdline );
		return $checklist;
	} else {
		my $cmd = process_arg shift @args;
		my $ok;
		/%/ and $ok = 1 for @args; # TODO: replace this with some var_triggered
		$ok or die "-exec expects at least one '{}' or variable argument\n";
		my @hashed_args = map { process_arg($_, $checklist) } @args;
		my @out = ();
		foreach my $pid ( @$checklist ) {
			my @cmdline = ($cmd);
			push @cmdline, map { $_->{$pid} } @hashed_args;
			system( @cmdline );
			push @out, $pid unless $? >> 8;
		}
		return [ @out ];
	}
}

sub cmd_human($@) {
	my ($list, @vars) = @_;
	@vars or die "-human takes at least one arg\n";
	# we do not use process_arg()
	foreach my $var ( @vars ) {
		$var =~ /^(-?)%([a-zA-Z]\w*)$/ or die "Bad -human arg: $var\n";
		$1 ? ( delete $is_human{$2} ) : ( $is_human{$2} = 1 );
	}
	return $list;
}

sub cmd_sort($$) {
	my ($checklist, $value) = @_;
	$value =~ /%[a-z]/ or die "-sort expects unquoted local variable argument\n";
	my $hashed_value = process_arg( $value, $checklist );
	foreach my $pid ( @$checklist ) {
		if( not defined $hashed_value->{$pid} ) {
			die "undefined value for $pid in -sort\n";
		} elsif( $hashed_value->{$pid} !~ /^-?\d+$/ ) {
			die "non-numeric value for $pid in -sort: $hashed_value->{$pid}\n";
		}
	}
	return [ sort {
		$hashed_value->{$a} <=> $hashed_value->{$b}
	} @$checklist ];
}

sub cmd_head($$) {
	my ($checklist, $num) = @_;
	$num = process_arg $num;
	die "-head expects positive numeric argument\n"
		unless $num =~ /^\d+$/ and $num > 0;
	my $total = @$checklist;
	$num = $total if $num > $total;
	return [ @$checklist[0..$num-1] ];
}
sub cmd_tail($$) {
	my ($checklist, $num) = @_;
	$num = process_arg $num;
	die "-tail expects positive numeric argument\n"
		unless $num =~ /^\d+$/ and $num > 0;
	my $total = @$checklist;
	$num = $total if $num > $total;
	return [ @$checklist[$total-$num .. $total-1] ];
}

sub parse_conf(@);
sub mktree(@);
sub evaltree($$);
sub cmd_source($$) {
	my ($list, $path) = @_;
	return evaltree( $list, mktree parse_conf read_file process_arg $path );
}

sub do_settree($$$);
sub do_settree($$$) {
	my ($children, $pid, $prefix ) = @_;
	my @out = ();
	my @mychildren = @{$children->{$pid}};
	while( @mychildren ) {
		my $child = shift @mychildren;
		my $childprefix = $pid ? "$prefix \\_ " : $prefix;
		$localcache->{$child}{"tree"} = $childprefix;
		push @out, $child;
		my $nextprefix =
			(not $pid) ? $prefix
			: @mychildren ? "$prefix |  "
			: "$prefix    ";
		if( $children->{$child} ) {
			push @out, do_settree( $children, $child, $nextprefix );
		}
	}
	return @out;
}
sub cmd_settree($) {
	my $checklist = shift;
	my %pidset = map { $_ => 1 } @$checklist;
	my $children = { 0 => [] };
	foreach my $pid ( sort { $a <=> $b } @$checklist ) {
		my $ppid = cached_get( $pid, "stat", "ppid" );
		if( $pidset{$ppid} and $ppid > 1 ) {
			$children->{$ppid} ||= [];
			push @{$children->{$ppid}}, $pid;
		} else {
			push @{$children->{0}}, $pid;
		}
	}
	$localcache->{$_}{"tree"} = "" foreach get_all_pids();
	my @sorted = do_settree( $children, 0, "" );
	return \@sorted;
}

my %cmd0 = (
	"true"	=> sub { return $_[0] },
	"false"	=> sub { return [] },
	"list"	=> \&cmd_list,
	"settree"	=> \&cmd_settree,
	"children"	=> sub { get_additions( shift, "children", \&inc_children, 1 ) },
	"descendants"	=> sub { get_additions( shift, "descendants", \&inc_children, undef ) },
	"parents"	=> sub { get_additions( shift, "parents", \&inc_parent, 1 ) },
	"ancestors"	=> sub { get_additions( shift, "ancestors", \&inc_parent, undef ) },
);
my %cmd1 = (
	"write"		=> sub { my $list = shift; do_write($list, shift); $list },
	"write1"	=> sub { my $list = shift; do_write(undef, shift); $list },
	"warnf"		=> \&cmd_warnf,
	"exit"		=> \&cmd_exit,
	"signal"	=> \&cmd_signal,
	"sort"		=> \&cmd_sort,
	"head"		=> \&cmd_head,
	"tail"		=> \&cmd_tail,
	"source"	=> \&cmd_source,
);
my %cmd2 = (
	# reserved for user-defined commands
);
my %cmdm = (
	"pids"		=> \&cmd_pids,
	"exec"		=> \&cmd_exec,
	"print"		=> sub { my $list = shift; print_table( $list, "print",  0, @_); $list },
	"print1"	=> sub { my $list = shift; print_table( undef, "print1", 0, @_); $list },
	"echo"		=> sub { my $list = shift; print_table( $list, "echo",   1, @_); $list },
	"echo1"		=> sub { my $list = shift; print_table( undef, "echo1",  1, @_); $list },
	"human"		=> \&cmd_human,
);
my %compare = ( # do not firget to edit %compare_match and %compare_num!
	"-m"	=> sub { $_[0] =~ pattern2re $_[1] },
	"=@"	=> "-m",
	"-nm"	=> sub { $_[0] !~ pattern2re $_[1] },
	"!@"	=> "-nm",
	"=~"	=> sub { $_[0] =~ $_[1] },
	"!~"	=> sub { $_[0] !~ $_[1] },
	"=="	=> sub { $_[0] eq $_[1] },
	"!="	=> sub { $_[0] ne $_[1] },
	-eq	=> sub { $_[0] == $_[1] },
	-ne	=> sub { $_[0] != $_[1] },
	-lt	=> sub { $_[0] < $_[1] },
	-le	=> sub { $_[0] <= $_[1] },
	-gt	=> sub { $_[0] > $_[1] },
	-ge	=> sub { $_[0] >= $_[1] },
);
# match operations have constant second argument:
my %compare_match = map {$_ => 1 } qw/ -m =@ -nm !@ =~ !~ /;
# arguments of numeric operations are checked to be numeric:
my %compare_num = map { $_ => 1 } qw/ -eq -ne -lt -le -gt -ge /;

my %cmdkeywords = map { "-" . $_ => 1 } ( 
		keys(%cmd0), keys(%cmd1), keys(%cmd2), keys(%cmdm),
);
my %keywords = map { $_ => 1 } (
	",", qw/ -comma ( ) [ ] { } {} ; ! -not -and -a -or -o -quote -q -cmd :=
		? : -if -then -elif -elsif -elseif -else -fi /,
	keys(%compare),
	keys(%cmdkeywords),
);
my %reserved = ( '=' => 'please replace `=` with `:=` for assignment or `==` for comparison' );
$reserved{$_} = "$_ is reserved, please use -quote $_ if you need to use it as string"
	foreach '#', qw( _ + - * \ | / ~ ^ . @ % $ " ' ` );

sub assign($;$) {
	my ($full_name, $value) = @_;
	# we do not use process_arg(), this is probably not good
	check_defined_scalar $full_name;
	# undefined $value will remove userfunc, ref is for conditional assignment
	$full_name =~ /^%(\w+)({(.*)})?$/ or
		die "left operand of := must be unquoted userfunc name with optional args: $full_name\n";
	die "empty argument string: $full_name\n" if length($2) and not length($3);
	my ($name, $args_str) = ($1, $3);
	$name =~ /^[a-zA-Z]/ or die "userfunc name must start with a letter\n";
	die "bad userfunc name $name: must be all upper or all lower case\n"
		if $name =~ /[A-Z]/ and $name =~ /[a-z]/;
	if( $getters0{$name} or $getters1{$name} ) {
		die "cannot assign to system variable \%$name\n";
	} elsif( not defined $value ) {
		delete $userfunc_values->{$name};
		delete $userfunc_args->{$name};
	} elsif( exists $userfunc_values->{$name} ) {
		die "userfunc \%$name already exists\n";
	} else {
		$userfunc_values->{$name} = $value;
		if( length $args_str ) {
			my @args = split /,/, $args_str;
			s/^%([a-zA-Z]\w*)$/$1/ or die "Bad argument for \%$name: $_\n"
				foreach @args;
			die unless @args;
			$userfunc_args->{$name} = [@args];
		}
	}
}

sub check_numeric($$$;$) {
	my ($arg1, $arg2, $name, $pid) = @_;
	my $pid_message = ( defined $pid ? " for PID $pid" : "" );
	die "left operand '$arg1' of $name is not numeric$pid_message\n"
		unless $arg1 =~ /^[\-\+]?\d+$/;
	die "right operand '$arg2' of $name is not numeric$pid_message\n"
		unless $arg2 =~ /^[\-\+]?\d+$/;
}
sub eval_compare($$$$) {
	my ($checklist, $name, $arg1, $arg2) = @_;
	check_defined_scalar $name;
	die if $name eq ":=";
	my $code = $compare{$name};
	$code = $compare{$code} if not ref $code;
	die $name unless 'CODE' eq ref $code;
	if( not defined $checklist ) { # -if condition or conditional assignment to global userfunc
		$arg1 = process_arg $arg1;
		$arg2 = process_arg $arg2;
		check_numeric $arg1, $arg2, $name if $compare_num{$name};
		return $code->( $arg1, $arg2 );
	} elsif( $compare_match{$name} ) {
		my $hashed_arg1 = process_arg( $arg1, $checklist );
		$arg2 = process_arg $arg2;
		return [ grep {
			$code->( $hashed_arg1->{$_}, $arg2 )
		} @$checklist ];
	} else {
		my $hashed_arg1 = process_arg( $arg1, $checklist );
		my $hashed_arg2 = process_arg( $arg2, $checklist );
		if( $compare_num{$name} ) {
			check_numeric $hashed_arg1->{$_}, $hashed_arg2->{$_}, $name, $_
				foreach @$checklist;
		}
		return [ grep {
			$code->( $hashed_arg1->{$_}, $hashed_arg2->{$_} )
		} @$checklist ];
	}
}

sub mklexer(@) {
	my @cmdline = @_;
	@cmdline or die "mklexer: empty cmdline\n";
	my @tokenized = ();
	my $lexer = sub {
		if( not @cmdline ) {
			push @tokenized, "(end of cmdline)";
			return ( '', undef );
		}
		my $current = shift @cmdline;
		push @tokenized, $current;
		if( exists $reserved{$current} ) {
			die "$reserved{$current}\n";
		} elsif( $current =~ /^-q(uote)?$/ ) {
			@cmdline or die "unexpected end of cmdline after $current\n";
			my $qstr = '\q' . shift @cmdline;
			$tokenized[$#tokenized] = $qstr;
			return ( 'STRING', $qstr );
		} elsif( $keywords{$current} ) {
			if( $cmdkeywords{$current} ) {
				$current =~ /^-(\w+)$/ or die;
				return ( 'CMDNAME', $1 );
			} else {
				return ( $current, $current );
			}
		} elsif( $current =~ /^-(\w+)$/ ) {
			return ( 'CMDNAME', $1 );
		} else {
			return ( 'STRING', $current );
		}
	};
	my $error_sub = sub {
		shift @tokenized while @tokenized > 5;
		die unless @tokenized;
		die "Unexpected $tokenized[$#tokenized]: ... @tokenized <<<<<HERE\n",
	};
	return $lexer, $error_sub;
}

sub unite_trees($@) {
	my ($op, @trees) = @_;
	die $op unless $op =~ /^(COMMA|OR|AND)$/;
	die $op unless @trees;
	my @united;
	while( @trees ) {
		my $current = shift @trees;
		defined $current or die;;
		ref $current or die $current;;
		'ARRAY' eq ref $current or die ref $current;
		if( $op eq $current->[0] ) {
			my @current_args = @$current;
			shift @current_args;
			die $op unless @current_args;
			unshift @trees, @current_args;
		} else {
			push @united, $current;
		}
	}
	die unless @united;
	return [ $op, @united ];
}

my $grammar = <<'GRAMMAR';
%expect 3
%{
	sub unite($@);
	*unite = \&main::unite_trees;
%}
%%
exp:	comma_exp ;
comma_exp:
	or_exp
	| or_exp commas			{ [ 'COMMA', $_[1] ] }
	| or_exp commas comma_exp	{ unite 'COMMA', $_[1], $_[3] }
	;
commas:
	comma
	| commas comma
	;
comma:
	','
	| '-comma'
	;
or_exp:
	and_exp
	| or_exp or and_exp	{ unite 'OR', $_[1], $_[3] }
	;
or:
	'-o'
	| '-or'
	;
and_exp:
	not_exp
	| not_exp and and_exp	{ unite 'AND', $_[1], $_[3] }
	;
and:
	/* empty */
	| '-a'
	| '-and'
	;
not_exp:
	atom
	| not not_exp		{ [ 'NOT', $_[2] ] }
	;
not:
	'-not'
	| '!'
	;
atom:
	command_exp
	| assignment
	| compare_exp
	| if_exp
	| cmd_definition
	| block
	;
command_exp:
	CMDNAME strings end_cmd			{ [ 'CMDRUN', $_[1], @{$_[2]} ] }
	| CMDNAME strings '{}' strings end_cmd	{ [ 'CMDRUN', $_[1], @{$_[2]}, '{}', @{$_[4]} ] }
	;
end_cmd:
	/* empty */
	| ';'
	;
strings:
	/* empty */		{ [] }
	| STRING strings	{ [ $_[1], @{$_[2]} ] }
	;
assignment:
	STRING ':=' assignment_value	{ [ 'ASSIGN', $_[1], $_[3] ] }
	;
assignment_value:
	STRING
	| '(' ca_expr ')'		{ $_[2] }
	| '{' ca_expr '}'		{ $_[2] }
	| '[' ca_expr ']'		{ $_[2] }
	;
compare_exp:
	STRING compare STRING	{ [ 'COMPARE', $_[2], $_[1], $_[3] ] }
	;
compare:
	'-m' | '=@' | '-nm' | '!@' | '=~' | '!~' | '==' | '!='
	| '-eq' | '-ne' | '-lt' | '-le' | '-gt' | '-ge'
	;
ca_expr:	# "ca" is for conditional assignment
	ca_options ca_default		{ [ 'CONDITIONAL', @{$_[1]}, $_[2] ] }
	;
ca_options:
	ca_option			{ [ $_[1] ] }
	| ca_options ca_option		{ [ @{$_[1]}, $_[2] ] }
	;
ca_option:
	condition '?' STRING ':'	{ ['OPTION', $_[1], $_[3]] }
	;
ca_default:
	STRING				{ ['DEFAULT', $_[1]] }
	;
if_exp:
	'-if' condition '-then' exp elsif_options maybe_else_option '-fi'
		{ [ 'IF', ['OPTION', $_[2], $_[4]], @{$_[5]}, @{$_[6]} ] }
	;
elsif_options:
	/* empty */			{ [] }
	| elsif_option elsif_options	{ [ $_[1], @{$_[2]} ] }
	;
elsif_option:
	elsif condition '-then' exp	{ ['OPTION', $_[2], $_[4]] }
	;
elsif:
	'-elif'
	| '-elsif'
	| '-elseif'
	;
maybe_else_option:
	/* empty */			{ [] }
	| '-else' exp			{ [ ['DEFAULT', $_[2]] ] }
	;
condition:
	compare_exp
	| not compare_exp		{ [ 'NOT', $_[2] ] }
	;
block:
	'(' exp ')'		{ [ 'BLOCK', $_[2] ] }
	| '{' exp '}'		{ [ 'BLOCK', $_[2] ] }
	| '[' exp ']'		{ [ 'BLOCK', $_[2] ] }
	;
cmd_definition:
	'-cmd' CMDNAME strings block	{ [ 'CMDDEF', $_[2], $_[3], $_[4] ] }
	;
%%
GRAMMAR

my $grammar_parser = new Parse::Yapp( input => $grammar );
eval $grammar_parser->Output(
	classname	=> "grammar_pfind",
);
die $@ if $@;
my $parser = new grammar_pfind;

sub mktree(@) {
	my @cmdline = @_;
	push @cmdline, "-true" unless @cmdline;
	my ($lexer, $error_sub) = mklexer(@cmdline);
	return $parser->YYParse(
		yylex => $lexer,
		yyerror => $error_sub,
	);
}

sub evalcmd($$@) {
	my ($list, $name, @args) = @_;
	check_defined_scalar $_ foreach @args;
	if( $cmd0{$name} ) {
		die "command $name takes no args\n" if @args;
		return $cmd0{$name}->($list);
	} elsif( $cmd1{$name} ) {
		die "command $name takes 1 arg\n" unless 1 == @args;
		my ($arg1) = (@args);
		return $cmd1{$name}->($list, $arg1);
	} elsif( $cmd2{$name} ) {
		die "command $name takes 2 args\n" unless 2 == @args;
		my ($arg1, $arg2) = (@args);
		return $cmd2{$name}->($list, $arg1, $arg2);
	} elsif( $cmdm{$name} ) {
		return $cmdm{$name}->($list, @args);
	} elsif( $usercmd_args->{$name} ) {
		my $num = scalar @{$usercmd_args->{$name}};
		die "user defined command -$name takes $num arguments\n"
			unless @args == $num;
		foreach my $i ( 0 .. $num-1 ) {
			assign( $usercmd_args->{$name}[$i], $args[$i] );
		}
		my $out = evaltree( $list, $usercmd_blocks->{$name} );
		foreach my $i ( 0 .. $num-1 ) {
			assign( $usercmd_args->{$name}[$i] ); # remove arg
		}
		return $out;
	} else {
		die "unknown command: $name\n";
	}
}

sub lists_substract($$) {
	my ($arg1, $arg2) = @_;
	'ARRAY' eq ref $_ or die for @_;
	my %skip = map { $_ => 1 } @$arg2;
	return [ grep { not $skip{$_} } @$arg1 ];
}

sub lists_add($$) {
	my ($arg1, $arg2) = @_;
	'ARRAY' eq ref $_ or die for @_;
	my %skip = map { $_ => 1 } @$arg1;
	my @addition = grep { not $skip{$_} } @$arg2;
	return [ @$arg1, @addition ];
}

sub evaltree($$) {
	my ($list_ref, $tree_ref) = @_;
	'ARRAY' eq ref $tree_ref or die;
	my $list = [ @$list_ref ]; my (@tree) = (@$tree_ref); # make copies
	my $op = shift @tree;
	if( $op eq 'BLOCK' ) {
		local $after_OR = undef; # this is why BLOCK is needed
		1 == @tree or die "$op takes one arg\n";
		return evaltree( $list, $tree[0] );
	} elsif( $op eq 'NOT' ) {
		local $after_OR = undef;
		1 == @tree or die "$op takes one arg\n";
		my $exp_result = evaltree( $list, $tree[0] );
		return lists_substract( $list, $exp_result );
	} elsif( $op eq 'COMMA' ) {
		local $after_OR = undef;
		@tree or die "$op takes at least one arg\n";
		my $out;
		foreach( @tree ) {
			$out = evaltree( $list, $_ );
			$previous_list = $out;
		}
		return $out;
	} elsif( $op eq 'OR' ) {
		@tree > 1 or die "$op takes at least two args\n";
		my $list2check = [ @$list ];
		my $list_result = [];
		my $first_arg = 1;
		foreach (@tree) {
			local $after_OR = not $first_arg;
			last unless @$list2check;
			my $out = evaltree( $list2check, $_ );
			$list2check = lists_substract( $list2check, $out );
			$list_result = lists_add( $list_result, $out );
			$previous_list = $list_result;
			$first_arg = undef;
		}
		return $list_result;
	} elsif( $op eq 'AND' ) {
		local $after_OR = undef;
		@tree > 1 or die "$op takes at least two args\n";
		foreach (@tree) {
			last unless @$list;
			$list = evaltree( $list, $_ );
			$previous_list = $list;
		}
		return $list;
	} elsif( $op eq 'IF' ) {
		local $after_OR = undef;
		@tree > 0 or die "$op takes at least one arg\n";
		foreach my $option ( @tree ) {
			die unless 'ARRAY' eq ref $option;
			if( $option->[0] eq 'DEFAULT' ) {
				die unless 2 == @$option;
				return evaltree( $list, $option->[1] );
			} elsif( $option->[0] eq 'OPTION' ) {
				die unless 3 == @$option;
				my( undef, $condition, $subtree ) = @$option;
				my $negative;
				if( $condition->[0] eq 'NOT' ) {
					die unless 2 == @$condition;
					$negative = 1;
					$condition = $condition->[1];
				}
				die unless 4 == @$condition;
				die unless 'COMPARE' eq $condition->[0];
				my( undef, $cmp_name, $left, $right ) = @$condition;
				if( $negative xor eval_compare( undef, $cmp_name, $left, $right ) ) {
					return evaltree( $list, $subtree );
				}
			} else {
				die;
			}
		}
		return $list;
	} elsif( $op eq 'CMDDEF' ) {
		local $after_OR = undef;
		3 == @tree or die;
		my ($name, $strings, $block) = @tree;
		$name =~ s/^-//;
		die "cannot define -$name: already defined\n"
			if exists $usercmd_blocks->{$name};
		die "cannot define -$name: it is a keyword\n"
			if exists $keywords{-$name};
		$usercmd_blocks->{$name} = $block;
		$usercmd_args->{$name} = $strings;
		return $list;
	} elsif( $op eq 'CMDRUN' ) {
		# $after_OR is not changed here
		@tree or die "no command name\n";
		my $name = shift @tree;
		$list = evalcmd( $list, $name, @tree );
		$previous_list = $list;
		return $list;
	} elsif( $op eq 'ASSIGN' ) {
		# $after_OR is not changed here
		2 == @tree or die;
		my ($left, $right) = @tree;
		assign( $left, $right );
		$previous_list = $list;
		return $list;
	} elsif( $op eq 'COMPARE' ) {
		# $after_OR is not changed here
		3 == @tree or die "$op takes three args\n";
		my ($compare_name, $left, $right) = @tree;
		$list = eval_compare( $list, $compare_name, $left, $right );
		$previous_list = $list;
		return $list;
	} elsif( $op eq 'EMPTY' ) {
		# $after_OR is not changed here
		return $list;
	} else {
		die "unknown op: $op\n";
	}
}

sub parse_conf(@) {
	my @out = ();
	conf_line:
	foreach my $line ( @_ ) {
		check_defined_scalar $line;
		chomp $line;
		while( length $line ) {
			if( $line =~ /^\s+(.*)$/ ) {
				$line = $1;
			} elsif( $line =~ /^#/ ) {
				next conf_line;
			} elsif( $line =~ /^(([\w%\/\-\(\){}\[\]\?:=\!,]|\\[\w\-\\])+)(.*)$/ ) {
				push @out, $1;
				$line = $3;
				if( length($line) and not $line =~ /^\s/ ) {
					die "unexpected character after token here: $line\n";
				}
			} elsif( $line =~ /^"/ ) {
				die "double quotes  are not allowed: $line\n";
			} elsif( $line =~ /^'/ ) {
				$line =~ /^'(([^\\']|\\[\w\-\\])*)'(.*)$/
					or die "bad line after `'`: $line\n";
				push @out, $1;
				$line = $3;
			} else {
				die "unexpected character here: $line\n";
			}
		}
	}
	return @out;
}

sub mydump($$) {
	my( $name, $value ) = @_;
	eval q{
		use Data::Dumper::LispLike;
		print "$name: " . dumplisp $value;
		exit 0;
	};
	local $Data::Dumper::Indent = 1;
	print Data::Dumper->Dump( [$value], [$name] );
	exit 0;
}

sub main() {
	my $quiet;
	my %dump_opt = ();
	my %candump = map { $_ => 1 } qw/tree keywords sysfunc usercmd userfunc/;
	my $default_cmd = "ps";
	my $no_preload;
	my @source_files = </etc/pfind/*.pfind>;
	if( length $ENV{HOME} ) {
		my $path = $ENV{HOME} . "/.pfind";
		push @source_files, $path if -f $path;
		push @source_files, <$path/*.pfind>;
	}
	while( @ARGV and $ARGV[0] =~ /^--/ ) {
		my $option = shift @ARGV;
		if( $option eq "--" ) {
			last;
		} elsif( $option eq "--quiet" ) {
			$quiet = 1;
		} elsif( $option eq "--dump" ) {
			@ARGV or die "dump what?\n";
			my $what = shift @ARGV;
			if( "help" eq $what ) {
				die sprintf "You can dump: %s\n",
					join ", ", keys %candump;
			} elsif( $candump{$what} ) {
				$dump_opt{$what} = 1;
			} else {
				die "don't know how to dump $what\n";
			}
		} elsif( $option eq "--list" ) {
			$default_cmd = "list";
		} elsif( $option eq "--no-preload" ) {
			$no_preload = 1;
		} elsif( $option eq "--source" ) {
			@ARGV or die "no filename after --source\n";
			push @source_files, shift @ARGV;
		} else {
			die "Unknown option: $option\n";
		}
	}
	$dump_opt{keywords} and die sprintf "%s\n", join " ", sort keys %keywords;
	$dump_opt{sysfunc} and die sprintf "%s\n", join " ", map {"%$_"} sort keys %sysfunc;
	my @subtrees;
	push @subtrees, mktree( parse_conf split /\n/, $preload ) unless $no_preload;
	push @subtrees, mktree( parse_conf read_file $_ ) foreach @source_files;
	push @subtrees, mktree( @ARGV );
	my $tree = [ 'COMMA', @subtrees ];
	$dump_opt{tree} and mydump( SyntaxTree => $tree );
	my $list = evaltree( [ get_all_pids() ], $tree );
	if( $dump_opt{usercmd} ) {
		$usercmd_args->{$_} or die $_ foreach keys %$usercmd_blocks;
		$usercmd_blocks->{$_} or die $_ foreach keys %$usercmd_args;
		my $out = [];
		foreach my $name ( keys %$usercmd_args ) {
			push @$out, [ "-$name", $usercmd_args->{$name}, $usercmd_blocks->{$name} ];
		}
		mydump( UserCmd => $out );
	}
	if( $dump_opt{userfunc} ) {
		$userfunc_values->{$_} or die $_ foreach keys %$userfunc_args;
		my $out = [];
		foreach my $name ( keys %$userfunc_values ) {
			my $args = ( $userfunc_args->{$name} || [] );
			s/^(.*)$/%$1/ foreach @$args;
			my $args_str = join( ",", @$args );
			my $full_name = ( @$args ? sprintf "%%%s{%s}", $name, $args_str : "%$name" );
			push @$out, [ $full_name => $userfunc_values->{$name} ];
		}
		mydump( UserFunc => $out );
	}
	evalcmd( $list, $default_cmd ) unless $quiet or $action_triggered;
	exit( @$list ? 0 : 1 );
}

main;
