#!/usr/bin/perl -w
# (c) 2012 Sergey Redin sergey@redin.info https://github.com/spiculator/pfind
use strict;
use Parse::Yapp;
my $state;
# a copy of previous expression's result
# for things like -children/-parents/-descendants/-ancestors:
my $previous_list;
our $after_OR = undef;

sub get_full_proc_list() {
	return $state->{"all"} if exists $state->{"all"};
	my $list = [];
	opendir PROC, "/proc" or die $!;
	while( readdir PROC ) {
		push @$list, $_ if /^\d+$/;
	}
	closedir PROC or die $!;
	return ( $state->{"all"} = $list );
}

sub check_list($) {
	my $list = shift;
	if( not defined $list ) {
		die "list not defined";
	} elsif( not ref $list ) {
		$list eq "all" or die;
		return get_full_proc_list;
	} elsif( "ARRAY" eq ref $list ) {
		return $list;
	} else {
		die;
	}
}

sub get_stat($) {
	my $pid = shift;
	open STAT, "/proc/$pid/stat" or return undef;
	my $line = <STAT>;
	return undef unless defined $line;
	close STAT or return undef;
	$line =~ /^(\d+) \((.*)\) (\w) (\d+(\s+-?\d+)+)$/ or die "bad stat: $line";
	my %out = ( pid => $1, comm => $2, state => $3 );
	my @rest = split /\s+/, $4;
	my @rest_names = qw(
		ppid pgrp session tty_nr tpgid flags
		minflt cminflt majflt cmajflt
		utime stime cutime cstime
		priority nice num_threads itrealvalue starttime
		vsize rss rsslim startcode endcode startstack
		kstkesp kstkeip signal blocked sigignore sigcatch
		wchan nswap cnswap exit_signal processor
		rt_priority policy delayacct_blkio_ticks guest_time cguest_time
	);
	while( @rest ) {
		my $value = shift @rest;
		last unless defined $value;
		my $name = shift @rest_names;
		$out{$name} = $value;
	}
	return \%out;
}

my %getters0 = ( # see also %alias0
	"pid"    => sub { return shift },
	"exe"	=> sub { readlink("/proc/$_[0]/exe") // "" },
	"cwd"	=> sub { readlink("/proc/$_[0]/cwd") // "" },
	"root"	=> sub { readlink("/proc/$_[0]/root") // "" },
);
my %getters1 = (
	"stat"	=> \&get_stat,
);

sub cached_get($$;@) {
	my ($pid, $name, @args) = @_;
	if( exists $getters0{$name} ) {
		0 == @args or die "function $name takes no arguments\n";
		return( $state->{$pid}{$name} //= $getters0{$name}->($pid) );
	} elsif( exists $getters1{$name} ) {
		1 == @args or die "function $name takes one argument\n";
		my ($arg1) = @args;
		$state->{$pid}{$name} //= $getters1{$name}->($pid);
		return $state->{$pid}{$name}{$arg1};
	} else {
		die "unknown function: $name";
	}
}

my %pattern2re_cache;
sub pattern2re($) {
	my $pattern = shift;
	my $re = $pattern2re_cache{$pattern};
	unless( $re ) {
		$re = $pattern;
		$re =~ s/([\\^.$|\(\)\[\]\{\}\+])/\\$1/g;
		$re =~ tr/?/./;
		$re =~ s/\*/.*/g;
		$re = "^$re\$";
		$re = qr/$re/;
		$pattern2re_cache{$pattern} = $re;
	}
	return $re;
}

sub find_by_prop($$$;@) {
	my ($list, $pattern, $name, @args) = @_;
	$list = check_list $list;
	return [ grep {
		cached_get($_, $name, @args) =~ pattern2re($pattern)
	} @$list ];
}

sub func_list($) {
	my $list = shift;
	my @sorted = sort { $a <=> $b } @$list;
	print "@sorted\n";
	return $list;
}

my %sprintf_escapes = (
	a	=> "\a",
	b	=> "\b",
	f	=> "\f",
	n	=> "\n",
	r	=> "\r",
	t	=> "\t",
	0	=> "\0",
	"\\"	=> "\\",
);

sub do_sprintf_escape($) {
	my $char = shift;
	die unless 1 == length $char;
	return $sprintf_escapes{$char} // "\\$char";
}

my %alias0 = (
	"ppid"	=> [ qw/stat ppid/ ],
	"comm"	=> [ qw/stat comm/ ],
	"state"	=> [ qw/stat state/ ],
);

sub get_value_for_printf($$) {
	my ($pid, $long_name) = @_;
	my ($name, @args) = split /::/, $long_name;
	if( $alias0{$name} ) {
		die "alias $name takes no arguments\n" if @args;
		my ($_name, @_args) = @{$alias0{$name}};
		return cached_get( $pid, $_name, @_args );
	} elsif( @args > 1 ) {
		...
	} elsif( 1 == @args ) {
		return cached_get( $pid, $name, @args );
	} elsif( 0 == @args ) {
		return cached_get( $pid, $name );
	} else {
		die;
	}
}

sub func_printf($$) {
	my ($list, $format) = @_;
	my @sorted = sort { $a <=> $b } @$list;
	my $out = "";
	foreach my $pid (@sorted) {
		my $add = $format;
		$add =~ s{\\(.)}{do_sprintf_escape($1)}ge;
		$add =~ s{\\x([01-9a-f][01-9a-f])}{chr hex $1}gie;
		$add =~ s{%([a-z]\w*(::[a-z]\w*)*)}{get_value_for_printf( $pid, $1 )}gie;
		$add =~ s{%\[([a-z]\w*(::[a-z]\w*)*)\]}{get_value_for_printf( $pid, $1 )}gie;
		$add =~ s{%\{([a-z]\w*(::[a-z]\w*)*)\}}{get_value_for_printf( $pid, $1 )}gie;
		$add =~ s{%\(([a-z]\w*(::[a-z]\w*)*)\)}{get_value_for_printf( $pid, $1 )}gie;
		$out .= $add;
	}
	print $out;
	return $list;
}

sub func_signal($$) {
	my ($list, $signal) = @_;
	$signal = uc $signal;
	return [ grep { kill $signal, $_ } @$list ];
}

sub func_additions($$$$) {
	my ($checklist, $name, $inc, $once) = @_;
	$after_OR or die "-$name must come after -or\n";
	my @out = ();
	my %previous = map { $_ => 1 } @$previous_list;
	my %left2check = map { $_ => 1 } @$checklist;
	delete $left2check{$_} foreach keys %previous;
	while( %previous and %left2check ) {
		# $inc MUST NOT change its arguments
		my @addition = $inc->( \%previous, \%left2check );
		last unless @addition;
		foreach my $pid ( @addition ) {
			next if $previous{$pid};
			die $pid unless $left2check{$pid};
			push @out, $pid;
			$previous{$pid} = 1;
			delete $left2check{$pid};
		}
		last if $once;
	}
	return [ @out ];
}

sub inc_children($$) {
	my ($previous, $left2check) = @_;
	my @addition;
	foreach my $pid ( keys %$left2check ) {
		my $ppid = cached_get( $pid, "stat", "ppid" );
		if( $previous->{$ppid} ) {
			push @addition, $pid;
		}
	}
	return @addition;
}
sub inc_parent($$) {
	my ($previous, $left2check) = @_;
	my @addition;
	foreach my $pid ( keys %$previous ) {
		my $ppid = cached_get( $pid, "stat", "ppid" );
		if( $left2check->{$ppid} ) {
			push @addition, $ppid;
		}
	}
	return @addition;
}

sub func_pids($$@) {
	my ($checklist, $marker, @pids) = @_;
	die "-pids takes only ';' end marker\n" unless $marker eq ';';
	die "-pids takes at least one argument\n" unless @pids;
	my %ok = map { $_ => 1 } @$checklist;
	return [ grep { $ok{$_} } @pids ];
}

sub func_exec($$@) {
	my ($checklist, $marker, @args) = @_;
	die "-exec takes at least two arguments\n" unless @args;
	my $ok = undef;
	foreach( @args ) {
		$ok = 1 if $_ eq '{}';
	}
	die "-exec expects at least one '{}' argument\n" unless $ok;
	if( $marker eq '+' ) {
		my @cmdline = ();
		foreach( @args ) {
			if( $_ eq '{}' ) {
				push @cmdline, @$checklist;
			} else {
				push @cmdline, $_;
			}
		}
		system( @cmdline );
		return $checklist;
	} elsif( $marker eq ';' ) {
		my @out = ();
		foreach my $pid ( @$checklist ) {
			my @cmdline = map {
				/^\{\}$/ ? $pid : $_
			} @args;
			system( @cmdline );
			push @out, $pid unless $? >> 8;
		}
		return [ @out ];
	} else {
		die;
	}
}

sub func_pidfile($$) {
	my ($checklist, $pidfile) = @_;
	open PIDFILE, "<", $pidfile or return [];
	my $pid = <PIDFILE>;
	return [] unless defined $pid;
	close PIDFILE or return [];
	chomp $pid;
	$pid =~ /^\d+$/ or return [];
	my %ok = map { $_ => 1 } @$checklist;
	$ok{$pid} or return [];
	return [ $pid ];
}

my %func0 = (
	"true"	=> sub { return $_[0] },
	"false"	=> sub { return [] },
	"list"	=> \&func_list,
	"kill"	=> sub { func_signal shift, "KILL" },
	"term"	=> sub { func_signal shift, "TERM" },
	"hup"	=> sub { func_signal shift, "HUP" },
	"children"	=> sub { func_additions( shift, "children", \&inc_children, 1 ) },
	"descendants"	=> sub { func_additions shift, "descendants", \&inc_children, undef },
	"parents"	=> sub { func_additions( shift, "parents", \&inc_parent, 1 ) },
	"ancestors"	=> sub { func_additions shift, "ancestors", \&inc_parent, undef },
);
my %func1 = ( # see also %alias0
	"exe"		=> sub { find_by_prop( shift, shift, "exe" ) },
	"cwd"		=> sub { find_by_prop( shift, shift, "cwd" ) },
	"root"		=> sub { find_by_prop( shift, shift, "root" ) },
	"printf"	=> \&func_printf,
	"signal"	=> \&func_signal,
	"ps"		=> sub { func_exec( shift, '+', 'ps', shift, '{}' ) },
	"pidfile"	=> \&func_pidfile,
);
my %func2 = (
	"status"	=> sub { ... },
	"stat"		=> sub { find_by_prop( $_[0], $_[2], "stat", $_[1] ) },
);
my %funcm = (
	"pids"		=> \&func_pids,
	"exec"		=> \&func_exec,
);

sub tokenize(@) {
	my @out = ();
	while(@_) {
		my $a = shift;
		if( $a =~ /^[\(\)\[\]\{\},]$/ ) { # parentheses and comma
			push @out, [ $a, $a ];
		} elsif( $a eq "!" or $a eq "-not" ) {
			push @out, [ 'NOT', $a ];
		} elsif( $a =~ /^-a(nd)?$/ ) {
			push @out, [ 'AND', $a ];
		} elsif( $a =~ /^-or?$/ ) {
			push @out, [ 'OR', $a ];
		} elsif( $a =~ /^-(\w+)$/ ) {
			my $name = $1;
			if( $func0{$name} ) {
				push @out, [ 'FUNC', [ 'FUNC', $name ] ];
			} elsif( $func1{$name} or $alias0{$name} ) {
				@_ or die "function $name must have an arg\n";
				push @out, [ 'FUNC', [ 'FUNC', $name, shift ] ];
			} elsif( $func2{$name} ) {
				@_ > 1 or die "function $name must have two args\n";
				push @out, [ 'FUNC', [ 'FUNC', $name, shift, shift ] ];
			} elsif( $funcm{$name} ) {
				my $marker = undef;
				my @args = ();
				while( @_ ) {
					my $next = shift;
					if( $next =~ /^[;\+]$/ ) { # '+' or ';'
						$marker = $next;
						last;
					} else {
						push @args, $next;
					}
				}
				die "$a arguments end marker not found\n"
					unless defined $marker;
				push @out, [ 'FUNC',
					[ 'FUNC', $name, $marker, @args ] ];
			} else {
				die "unknown function: $name\n";
			}
		} else {
			die "unknown token: $a\n";
		}
	}
	return [ @out ];
}

sub mklexer($) {
	my $tokens_ref = shift;
	my @tokens = @$tokens_ref;
	return sub {
		if( @tokens ) {
			my $token = shift @tokens;
			return ( @$token );
		} else {
			return ( '', undef );
		}
	}
}

my $grammar = <<'GRAMMAR';
%%
exp:	comma_exp ;
comma_exp:
	or_exp
	| or_exp ',' comma_exp	{ [ 'COMMA', $_[1], $_[3] ] }
	;
or_exp:
	and_exp
	| or_exp OR and_exp	{ [ 'OR', $_[1], $_[3] ] }
	;
and_exp:
	not_exp
	| not_exp and and_exp	{ [ 'AND', $_[1], $_[3] ] }
	;
and:
	#empty
	| AND # -a | -and
	;
not_exp:
	atom
	| NOT not_exp		{ [ 'NOT', $_[2] ] }
	;
atom:
	FUNC
	| block
	;
block:
	'(' exp ')'		{ [ 'BLOCK', $_[2] ] }
	| '{' exp '}'		{ [ 'BLOCK', $_[2] ] }
	| '[' exp ']'		{ [ 'BLOCK', $_[2] ] }
	;
%%
GRAMMAR

sub mktree(@) {
	my @cmdline = @_;
	push @cmdline, "-true" unless @cmdline;

	my $grammar_parser = new Parse::Yapp( input => $grammar );
	eval $grammar_parser->Output(
		classname	=> "grammar_pfind",
	);
	die $@ if $@;

	my $parser = new grammar_pfind;
	return $parser->YYParse(
		yylex => mklexer( tokenize @cmdline ),
		yyerror => sub{ die "Parse error\n" },
	);
}

sub evalfunc($$@) {
	my ($list, $name, @args) = @_;
	if( $alias0{$name} ) {
		die "alias $name takes 1 arg\n" unless 1 == @args;
		my ($_name, @_args) = ( @{$alias0{$name}}, @args );
		die unless 2 == @_args;
		return $func2{$_name}->($list, @_args);
	} elsif( $func0{$name} ) {
		die "function $name takes no args\n" if @args;
		return $func0{$name}->($list);
	} elsif( $func1{$name} ) {
		die "function $name takes 1 arg\n" unless 1 == @args;
		my ($arg1) = (@args);
		return $func1{$name}->($list, $arg1);
	} elsif( $func2{$name} ) {
		die "function $name takes 2 args\n" unless 2 == @args;
		my ($arg1, $arg2) = (@args);
		return $func2{$name}->($list, $arg1, $arg2);
	} elsif( $funcm{$name} ) {
		return $funcm{$name}->($list, @args);
	} else {
		die "unknown function: $name\n";
	}
}

sub lists_substract($$) {
	my ($arg1, $arg2) = @_;
	'ARRAY' eq ref $_ or die for @_;
	my %skip = map { $_ => 1 } @$arg2;
	return [ grep { not $skip{$_} } @$arg1 ];
}

sub lists_add($$) {
	my ($arg1, $arg2) = @_;
	'ARRAY' eq ref $_ or die for @_;
	my %skip = map { $_ => 1 } @$arg1;
	my @addition = grep { not $skip{$_} } @$arg2;
	return [ @$arg1, @addition ];
}

sub evaltree($$);
sub evaltree($$) {
	my ($list_ref, $tree_ref) = @_;
	'ARRAY' eq ref $tree_ref or die;
	my $list = [ @$list_ref ]; my (@tree) = (@$tree_ref); # make copies
	my $op = shift @tree;
	if( $op eq 'BLOCK' ) {
		local $after_OR = undef; # this is why BLOCK is needed
		1 == @tree or die "$op takes one arg\n";
		return evaltree( $list, $tree[0] );
	} elsif( $op eq 'NOT' ) {
		local $after_OR = undef;
		1 == @tree or die "$op takes one arg\n";
		my $exp_result = evaltree( $list, $tree[0] );
		return lists_substract( $list, $exp_result );
	} elsif( $op eq 'COMMA' ) {
		local $after_OR = undef;
		@tree > 1 or die "$op takes at least two args\n";
		my $out;
		foreach( @tree ) {
			$out = evaltree( $list, $_ );
			$previous_list = $out;
		}
		return $out;
	} elsif( $op eq 'OR' ) {
		@tree > 1 or die "$op takes at least two args\n";
		my $list2check = [ @$list ];
		my $list_result = [];
		my $first_arg = 1;
		foreach (@tree) {
			local $after_OR = not $first_arg;
			last unless @$list2check;
			my $out = evaltree( $list2check, $_ );
			$list2check = lists_substract( $list2check, $out );
			$list_result = lists_add( $list_result, $out );
			$previous_list = $list_result;
			$first_arg = undef;
		}
		return $list_result;
	} elsif( $op eq 'AND' ) {
		local $after_OR = undef;
		@tree > 1 or die "$op takes at least two args\n";
		$list = check_list $list;
		foreach (@tree) {
			last unless @$list;
			$list = evaltree( $list, $_ );
			$previous_list = $list;
		}
		return $list;
	} elsif( $op eq 'FUNC' ) {
		# $after_OR is not changed here
		@tree or die "no function name\n";
		my $name = shift @tree;
		$list = evalfunc( $list, $name, @tree );
		$previous_list = $list;
		return $list;
	} else {
		die "unknown op: $op\n";
	}
}

my %is_action = map { $_ => 1 } qw(
	list printf
	signal kill term hup
	exec ps
);
sub tree_has_actions($);
sub tree_has_actions($) {
	my $tree = shift;
	my @copy = @$tree;
	my $op = shift @copy;;
	if( $op =~ /^(BLOCK|NOT|COMMA|OR|AND)$/ ) {
		foreach my $subtree (@copy) {
			return 1 if tree_has_actions($subtree);
		}
		return undef;
	} elsif( $op eq 'FUNC' ) {
		my $name = shift @copy;
		return $is_action{$name};
	} else {
		die "unknown op: $op\n";
	}
}

sub main() {
	my $tree = mktree( @ARGV ); ############### ./pfind -true -or [ -exe test -cwd / -o -status envID 123 ]
	#use Data::Dumper; print "tree: ", Dumper $tree; ##############################
	my $do_print_list = not tree_has_actions($tree);
	my $value = evaltree( get_full_proc_list(), $tree );
	#use Data::Dumper; print "value: ", Dumper $value; ##############################
	func_list($value) if $do_print_list;
}

main;

#use Data::Dumper; print Dumper find_by_prop "all", "pe", "exe"; ################
#use Data::Dumper; print Dumper find_by_prop "all", "/proc/7613", "cwd"; ################
#use Data::Dumper; print Dumper $state; ##############
